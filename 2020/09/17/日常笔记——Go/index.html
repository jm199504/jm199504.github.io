<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>日常笔记——Go | Jimmy&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述：日常笔记——Go">
<meta property="og:type" content="article">
<meta property="og:title" content="日常笔记——Go">
<meta property="og:url" content="http://example.com/2020/09/17/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Go/index.html">
<meta property="og:site_name" content="Jimmy&#39;s blog">
<meta property="og:description" content="概述：日常笔记——Go">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/images/go_utils1.png">
<meta property="og:image" content="http://example.com/images/go_utils2.png">
<meta property="article:published_time" content="2020-09-17T15:21:12.788Z">
<meta property="article:modified_time" content="2021-04-01T05:33:43.219Z">
<meta property="article:author" content="Jimmy Guo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/images/go_utils1.png">
  
    <link rel="alternate" href="/atom.xml" title="Jimmy's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jimmy&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-日常笔记——Go" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2020/09/17/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Go/" class="article-date">
  <time class="dt-published" datetime="2020-09-17T15:21:12.788Z" itemprop="datePublished">2020-09-17</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Go/">Go</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      日常笔记——Go
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>概述：日常笔记——Go</p>
<span id="more"></span>

<h1 id="1-Go语言"><a href="#1-Go语言" class="headerlink" title="1.Go语言"></a>1.Go语言</h1><p>Go语言也称 Golang，兼具效率、性能、安全、健壮等特性，部署简单，Go编译生成静态可执行文件，除glibc外无其他外部依赖，可直接编译成机器码，语言层面支持并发执行，内置runtime，支持垃圾回收，含丰富的标准库，可跨平台编译。</p>
<p>Go语言适合用于服务器编程，处理日志、数据打包、虚拟机处理、文件系统，网络编程，云平台开发等，另外可基于Go实现Web开发、内网穿透、高性能爬虫等等。</p>
<h1 id="2-Go语法示范网站"><a href="#2-Go语法示范网站" class="headerlink" title="2.Go语法示范网站"></a>2.Go语法示范网站</h1><p>（1）Example：<a target="_blank" rel="noopener" href="https://gobyexample.com/">https://gobyexample.com/</a></p>
<p>（2）Video-尚硅谷韩顺平Go语言核心编程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/av35928275">https://www.bilibili.com/video/av35928275</a></p>
<h1 id="3-Hello-World"><a href="#3-Hello-World" class="headerlink" title="3.Hello World"></a>3.Hello World</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="comment">//package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="comment">//fmt 包实现了格式化 IO（输入/输出）的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">//main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</span></span><br><span class="line">    fmt.Println(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="4-变量和静态变量、变量类型"><a href="#4-变量和静态变量、变量类型" class="headerlink" title="4.变量和静态变量、变量类型"></a>4.变量和静态变量、变量类型</h1><p>4.1 使用var关键字声明变量，可不设置变量类型，标准格式<strong>var 变量名 变量类型 = 变量值</strong>，可同时声明多个变量，无须分号结尾，且变量必须使用/输出，在函数外声明变量为全局变量，另外Golang严格区分大小写，“_”为特殊标识符，成为空标识符，它对应值通常会被忽略，通常被用于占位符使用，特例：变量名可以用int、float32，开发不建议使用，程序可编译通过</p>
<p>Tip：全局变量不能在函数外赋值（不等同于初始化）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">100</span> <span class="comment">// 可执行</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">string</span> <span class="comment">// 可执行</span></span><br><span class="line">b = <span class="string">&quot;111&quot;</span> <span class="comment">// × 语法错误</span></span><br><span class="line">name := <span class="string">&quot;jun&quot;</span> <span class="comment">// ×语法错误（左侧变量不应该是已声明过的）</span></span><br></pre></td></tr></table></figure>

<p>4.2 静态变量可以不使用/输出，使用关键字const声明静态变量</p>
<p>4.3 变量类型含基本数据类型：</p>
<p>数值型：（int,int{x},unint,uint{x},byte,float32,float64）、字符型、布尔型、字符串型；</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>有无符号</th>
<th>占用存储空间</th>
<th>数范围</th>
</tr>
</thead>
<tbody><tr>
<td>int{x}</td>
<td>有</td>
<td>{x}*1字节|或理解为x位</td>
<td>-2^{x}~(2^{x}-1)</td>
</tr>
<tr>
<td>uint{x}</td>
<td>无</td>
<td>{x}*1字节</td>
<td>0~(2^{x+1}-1)</td>
</tr>
<tr>
<td>单精度float32</td>
<td>有</td>
<td>4字节</td>
<td>-3.403E38~3.403E38</td>
</tr>
<tr>
<td>双精度float64</td>
<td>有</td>
<td>8字节</td>
<td>-1.798E308~1.798E308</td>
</tr>
</tbody></table>
<p>Go语言字符使用UTF-8编码，英文字母为1个字节，中文为3个字节</p>
<p>派送/复杂数据类型：指针、数组、结构体、管道、函数、切片、接口、集合</p>
<p>另外一种划分方式：值类型和引用类型</p>
<p>值类型：基本数据类型int系列、float系列、bool、string、数组、结构体。|| 变量直接存储值，内存通常在栈中分配；</p>
<p>引用类型：指针、slice切片、map集合、管道、interface。|| 变量存储地址，该地址对应空间为真正存储数据值，内存通常在堆分配，当没有任何变量引用该地址，则地址对应的数据空间为垃圾地址，需要进行垃圾回收</p>
<p>通常约定：变量名、函数名、常量名的首字母大写则可以被其他包访问，若首字母小写则在本包使用，即只有首字母大写的变量才可以被其他包使用</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;example&quot;</span></span><br><span class="line"><span class="keyword">var</span> b,c <span class="keyword">int</span> = <span class="number">123</span>,<span class="number">222</span></span><br><span class="line">o := <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> d,e,f = <span class="number">100</span>,<span class="string">&quot;eee&quot;</span>,<span class="number">888</span> <span class="comment">//一次性声明多个变量</span></span><br><span class="line">g,h,j := <span class="number">-11</span>,<span class="literal">true</span>,<span class="string">&quot;aaa&quot;</span> <span class="comment">//一次性声明多个变量</span></span><br><span class="line"><span class="keyword">var</span>(</span><br><span class="line">n1 = <span class="number">100</span></span><br><span class="line">n2 = <span class="number">200</span></span><br><span class="line">)<span class="comment">//一次性声明多个变量</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="string">&quot;ssssss&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sss = <span class="string">&quot;hello&quot;</span></span><br><span class="line">sss[<span class="number">0</span>] = <span class="string">&quot;a&quot;</span><span class="comment">//在Go中string不可变，该语句ERROR</span></span><br><span class="line">aaa :=<span class="string">`</span></span><br><span class="line"><span class="string">	func zeroptr(iptr *int) &#123;</span></span><br><span class="line"><span class="string">	*iptr = 0</span></span><br><span class="line"><span class="string">&#125;`</span></span><br><span class="line">fmt.Println(aaa)<span class="comment">//字符串中包含关键字符时可使用反引号\`</span></span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;n1类型%T\n&quot;</span>,n1)<span class="comment">//查看数据类型（注意是Printf而不是Println）</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n1占用字节数：%d&quot;</span>,unsafe.Sizeof(n1))<span class="comment">//查看变量占用的字节大小（需导入unsafe包）</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c1 <span class="keyword">byte</span> = <span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="keyword">var</span> c2 <span class="keyword">byte</span> = <span class="string">&quot;0&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;c1=&quot;</span>,c1)#直接输出<span class="keyword">byte</span>即输出ASCII值 a=&gt;<span class="number">97</span></span><br><span class="line">fmt.Println(<span class="string">&quot;c2=&quot;</span>,c2)#<span class="number">0</span>=&gt;<span class="number">48</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;c1=%c,c2=%c&quot;</span>,c1,c2)#格式化输出</span><br><span class="line"><span class="keyword">var</span> c3 <span class="keyword">byte</span> = <span class="string">&quot;好&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;c3=&quot;</span>,c3)#ERROR:overflow <span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> c4 <span class="keyword">int</span> = <span class="string">&quot;好&quot;</span></span><br><span class="line">fmt.Println(<span class="string">&quot;c4=&quot;</span>,c4)#输出ASCII值</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">float32</span></span><br><span class="line"><span class="keyword">var</span> c <span class="keyword">float64</span></span><br><span class="line"><span class="keyword">var</span> d <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> name <span class="keyword">string</span> </span><br><span class="line">fmt.Println(<span class="string">&quot;a=%d,b=%f,c=%f,d=%v,name=%v&quot;</span>) <span class="comment">//格式化输出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//在工作目录调用其他go文件中的变量</span></span><br><span class="line"><span class="comment">//起初已经在另外一个文件夹model中新建util.go并定义变量HeroName</span></span><br><span class="line">(util.<span class="keyword">go</span>)<span class="keyword">var</span> HeroName <span class="keyword">string</span> = <span class="string">&quot;aaaaaa&quot;</span></span><br><span class="line"></span><br><span class="line">(hello.<span class="keyword">go</span>)<span class="keyword">import</span> (<span class="string">&quot;awesomeProject/model&quot;</span>)</span><br><span class="line">(hello.<span class="keyword">go</span>)fmt.Println(model.HeroName)</span><br></pre></td></tr></table></figure>

<h1 id="5-批量导入函数"><a href="#5-批量导入函数" class="headerlink" title="5.批量导入函数"></a>5.批量导入函数</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math&quot;</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> n = <span class="number">6.28</span></span><br><span class="line">	fmt.Println(math.Cos(n))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="6-强制转换类型"><a href="#6-强制转换类型" class="headerlink" title="6.强制转换类型"></a>6.强制转换类型</h1><p>任何类型间转换均需要强制转换</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6.66</span></span><br><span class="line">fmt.Println(<span class="keyword">int64</span>(a))<span class="comment">//int、float之间均参考该格式</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//其他基本数据类型转string</span></span><br><span class="line"><span class="comment">//方法一：使用fmt.Sprintf(&quot;%参数&quot;,表达式)，生成格式化的字符串</span></span><br><span class="line"><span class="keyword">var</span> num1 <span class="keyword">int</span> = <span class="number">99</span></span><br><span class="line"><span class="keyword">var</span> num2 <span class="keyword">float32</span> = <span class="number">2.45</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span> = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">str = fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,num1)</span><br><span class="line">fmt.Println(str)</span><br><span class="line"></span><br><span class="line">str = fmt.Sprintf(<span class="string">&quot;%f&quot;</span>,num2)</span><br><span class="line">fmt.Println(str)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T\n&quot;</span>,str)<span class="comment">//==&gt;string类型</span></span><br><span class="line"></span><br><span class="line">str = fmt.Sprintf(<span class="string">&quot;%t&quot;</span>,b)</span><br><span class="line">fmt.Println(str)</span><br><span class="line"><span class="comment">//方法二：使用strconv包的函数</span></span><br><span class="line"><span class="comment">//strconv的Format*方法有：FormatBool、FormatFloat(float64类型形参)、FormatInt(int64类型形参)</span></span><br><span class="line"><span class="keyword">var</span> num3 <span class="keyword">int</span>= <span class="number">99</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span></span><br><span class="line">str = strconv.FormatInt(<span class="keyword">int64</span>(num3),<span class="number">10</span>)<span class="comment">//第2个参数base\=10表示10进制，其范围在2-36之间</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;str&#x27;s type is %T, str&#x27;s value is %s\n&quot;</span>,str,str)</span><br><span class="line"><span class="keyword">var</span> num4 <span class="keyword">float64</span> = <span class="number">9.22</span></span><br><span class="line">str = strconv.FormatFloat(num4,<span class="number">10</span>,<span class="number">64</span>)<span class="comment">//第2个&#x27;f&#x27;表示格式，第3个参数表示小数10保留10,第4个64表示float64</span></span><br><span class="line"><span class="comment">//strconv包有一个函数Itoa也可以转换int到string，处理int类型而不是int64</span></span><br><span class="line"><span class="keyword">var</span> num5 <span class="keyword">int</span> = <span class="number">4567</span></span><br><span class="line">str = strconv.Itoa(num5)</span><br><span class="line"></span><br><span class="line"><span class="comment">//string转其他基本数据类型</span></span><br><span class="line"><span class="comment">//使用strconv中的Parse*方法</span></span><br><span class="line"><span class="comment">//ParseBool、ParseFloat、ParseInt、ParseUint</span></span><br><span class="line"><span class="comment">//String转Bool</span></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;true&quot;</span></span><br><span class="line"><span class="keyword">var</span> b <span class="keyword">bool</span></span><br><span class="line">b,_ = strconv.ParseBool(str)<span class="comment">//返回两个值，第一个为返回值，第二个为错误ERROR</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;b&#x27;s type is&#x27;：%T,b&#x27;s value is&#x27;%t&quot;</span>,b,b)</span><br><span class="line"><span class="comment">//Output:b&#x27;s type is&#x27;：bool,b&#x27;s value is&#x27;true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String转Int</span></span><br><span class="line"><span class="keyword">var</span> str1 <span class="keyword">string</span> = <span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int64</span></span><br><span class="line">n1,_ = strconv.ParseInt(str1,<span class="number">10</span>,<span class="number">64</span>)<span class="comment">//第2个参数为10进制，第3个参数为int64</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n1&#x27;s type is&#x27;：%T,n1&#x27;s value is&#x27;%d&quot;</span>,n1,n1)</span><br><span class="line"><span class="comment">//Output:n1&#x27;s type is&#x27;：int64,n1&#x27;s value is&#x27;11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//String转Float</span></span><br><span class="line"><span class="keyword">var</span> str2 <span class="keyword">string</span> = <span class="string">&quot;22.22&quot;</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">float64</span></span><br><span class="line">n2,_ = strconv.ParseFloat(str2,<span class="number">64</span>)<span class="comment">//第2个参数为float64</span></span><br><span class="line">fmt.Printf(<span class="string">&quot;n2&#x27;s type is&#x27;：%T,n2&#x27;s value is&#x27;%f&quot;</span>,n2,n2)</span><br><span class="line"><span class="comment">//Output:n2&#x27;s type is&#x27;：float64,n2&#x27;s value is&#x27;22.220000</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="7-For循环"><a href="#7-For循环" class="headerlink" title="7.For循环"></a>7.For循环</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在for中使用之前定义/声明的变量</span></span><br><span class="line">i := <span class="number">1</span><span class="comment">// 循环变量初始化</span></span><br><span class="line"><span class="keyword">for</span> i &lt;= <span class="number">3</span>&#123;</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	i = i+<span class="number">1</span><span class="comment">//使用i++也可以代替该语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在for中定义/声明变量</span></span><br><span class="line"><span class="keyword">for</span> j:=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++&#123;</span><br><span class="line">	fmt.Println(j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for;;循环（通常配合break）</span></span><br><span class="line"><span class="keyword">var</span> k = <span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> k &gt;<span class="number">5</span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;k&gt;5&quot;</span>)</span><br><span class="line">		<span class="keyword">break</span></span><br><span class="line">	&#125;</span><br><span class="line">	k++</span><br><span class="line">	fmt.Println(k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串遍历-for（For循环是以字节读取，而对于字符串中含中文时会出现乱码问题，原因在于中文字符在utf-8编码中对应3个字节），如果强制使用for循环，可使用切片将string类型转成[]rune切片即可，但是转换后需要定义新变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str <span class="keyword">string</span> = <span class="string">&quot;helloWorld&quot;</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(str);i++&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c\t&quot;</span>,str[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str2 <span class="keyword">string</span> = <span class="string">&quot;helloWorld哈喽&quot;</span></span><br><span class="line">str3 := []<span class="keyword">rune</span>(str2)<span class="comment">//转成[]rune切片</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(str3);i++&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c\t&quot;</span>,str3[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串遍历-range，该方法返回index和value，不使用index则用&quot;_&quot;存储，该方法使用字符遍历，因此遇到中文字符不会出现乱码</span></span><br><span class="line"><span class="keyword">for</span> _,value := <span class="keyword">range</span> str&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%c\t&quot;</span>,value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Tip1：可使用break永久跳出循环</p>
<p>Tip2：可使用continue跳跃该次循环</p>
<h1 id="8-判断IF-ELSE"><a href="#8-判断IF-ELSE" class="headerlink" title="8.判断IF/ELSE"></a>8.判断IF/ELSE</h1><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a,b = <span class="number">100</span>,<span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> a &gt; b&#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;a &gt; b&quot;</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;a &lt;= b&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-Switch"><a href="#9-Switch" class="headerlink" title="9.Switch"></a>9.Switch</h1><p>Golang中可在一个case后可有多个表达式，使用”,”间隔</p>
<p>Tip1：表达式可以是常量值、变量、一个有返回值的函数之一均可</p>
<p>Tip2：case后的表达式和switch后接表达式的数据类型必须一致</p>
<p>Tip3：case后的表达式不能重复</p>
<p>Tip4：default不是必填项</p>
<p>Tip5：switch后可定义/声明变量，但需要后接“；”（不推荐）</p>
<p>Tip6：switch穿透-fallthrough，如果在case语句后增加fallthrough则会继续执行下一个case，称为switch穿透（默认穿透1层）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> a &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">10</span>,<span class="number">40</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i = 10 or 40&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i = 20&quot;</span>)</span><br><span class="line"><span class="keyword">case</span> <span class="number">30</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i = 30&quot;</span>)</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	fmt.Println(<span class="string">&quot;i not in (10,20,30,40)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch有返回值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(key <span class="keyword">int</span>)</span> <span class="title">int</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> key</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">switch</span> test(<span class="number">10</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>,<span class="number">40</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i = 10 or 40&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;i not in (10,40)&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch和case后接变量</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int32</span> = <span class="number">3</span></span><br><span class="line"><span class="keyword">var</span> n2 <span class="keyword">int32</span> = <span class="number">5</span></span><br><span class="line"><span class="keyword">switch</span> n1 &#123;</span><br><span class="line">	<span class="keyword">case</span> n2:</span><br><span class="line">		fmt.Println(<span class="string">&quot;匹配n2&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;不匹配n2&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch后声明变量</span></span><br><span class="line"><span class="keyword">switch</span> n1 := <span class="number">100</span>; &#123;</span><br><span class="line">	<span class="keyword">case</span> n1&gt;<span class="number">90</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;&gt;90&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;&lt;=90&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//switch穿透</span></span><br><span class="line"><span class="keyword">var</span> n1 <span class="keyword">int</span> = <span class="number">10</span></span><br><span class="line"><span class="keyword">switch</span> n1&#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="number">10</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;10&quot;</span>)</span><br><span class="line">		<span class="keyword">fallthrough</span><span class="comment">//（穿透一次执行下一个case的输出）</span></span><br><span class="line">	<span class="keyword">case</span> <span class="number">20</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;20&quot;</span>)</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		fmt.Println(<span class="string">&quot;&gt;20 or &lt;10&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：10 \n 20</span></span><br></pre></td></tr></table></figure>

<h1 id="10-输出今日星期-小时"><a href="#10-输出今日星期-小时" class="headerlink" title="10.输出今日星期/小时"></a>10.输出今日星期/小时</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a := time.Now().Weekday()//星期</span><br><span class="line">fmt.Println(a)</span><br><span class="line"><span class="keyword">if</span> a == time.Saturday&#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;今天是周六&quot;</span>)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	fmt.Print(<span class="string">&quot;今天不是周六&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">b := time.Now()//小时</span><br><span class="line">fmt.Println(b.Hour())</span><br></pre></td></tr></table></figure>

<h1 id="11-函数"><a href="#11-函数" class="headerlink" title="11.函数"></a>11.函数</h1><p>Go语言中函数分为自定义函数，系统函数</p>
<p>在Go使用interface()可用于向函数传递任意类型的变量，在函数内部，该变量仍为interface{}类型，注意函数的输入参数通常需要判断类型后再强制转换，不然易报错</p>
<p>函数格式：func 函数名(形参名 形参类型) 函数返回类型{…}</p>
<p>规范：通常不会将项目所需要所有函数写入mian文件，一般写入utils.go，该go文件专门用于定义函数，由main或者其他文件调用，其中会被其他文件引用的函数名必须<u>首字母</u>大写，或理解为该函数可导出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 使用interface不定义形参类型</span><br><span class="line">myfunc := func(i interface&#123;&#125;) &#123;</span><br><span class="line">	switch i.(<span class="built_in">type</span>) &#123;</span><br><span class="line">	<span class="keyword">case</span> string:</span><br><span class="line">		fmt.Println(<span class="string">&quot;string&quot;</span>,i.(string))</span><br><span class="line">	<span class="keyword">case</span> int:</span><br><span class="line">		fmt.Println(<span class="string">&quot;int&quot;</span>,i.(int))</span><br><span class="line">	default:</span><br><span class="line">	fmt.Printf(<span class="string">&quot;others&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myfunc(100)</span><br><span class="line">myfunc(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"></span><br><span class="line">// 明确函数的形参类型</span><br><span class="line">myfunc2 := func(a int,b int)&#123;</span><br><span class="line">	fmt.Println(a+b)</span><br><span class="line">&#125;</span><br><span class="line">myfunc2(1,2)</span><br><span class="line"></span><br><span class="line">// 定义多个形参类型</span><br><span class="line">myfunc3 := func(a, b, c int) int &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在外部定义函数（必须在main函数外定义）</span><br><span class="line">func plus1(a, b, c int) int &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在外部定义函数，多个返回值（必须在main函数外定义）</span><br><span class="line">func plus2(a, b, c int) (int,string) &#123;</span><br><span class="line">    <span class="built_in">return</span> a + b + c,<span class="string">&quot;sum&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>关于上述中调用utils文件函数截图举例：</p>
<p>Tip1：注意通常导入时文件包名和文件夹名一致，即utils.go所在的文件夹名为utils，则文件中第一行规范书写为packge utils，一般为小写，package后的包名不是必须与包名一致，不过建议一致，不然影响开发效率</p>
<p>Tip2：导入时语法为包名.函数名</p>
<p>Tip3：给包名其别名，将utils更改为util，其原名则失效，使用方法则为别名.函数名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import util <span class="string">&quot;awesomeProject/utils&quot;</span></span><br></pre></td></tr></table></figure>

<img src="/images/go_utils1.png">

<img src="/images/go_utils2.png">

<p>Tip3：将go文件编译成可执行文件，需要将包声明为main，即package main，在$GOPATH执行</p>
<blockquote>
<p>举例：个人GOPATH在C:\Users\Junming\go下，则在该目录下启动CMD，而目标文件在C:\Users\Junming\go\src\awesomeProject\main\helloworld.go，在执行命令时直接以src下定位，命令如下</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Junming\go&gt;go build awesomeProject\main</span><br></pre></td></tr></table></figure>

<p>编译后生成一个有默认名的可执行文件，在$GOPATH目录下，也可以指定名字和目录，以上命令执行后会在GOPATH下生成一个main.exe，同时可自定义设置存储名字与路径：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Junming\go&gt;go build -o bin/my.exe awesomeProject\main</span><br></pre></td></tr></table></figure>

<p>Tip：以上执行后其实会在pkg文件夹中...\下生成utils.a，该文件为库文件（二进制文件）</p>
<p><strong>函数调用机制底层解析：</strong></p>
<p>栈区：基本数据类型</p>
<p>堆区：引用数据类型</p>
<p>（1）调用函数时会分配一个新的空间，编译器会将该函数对应的栈与其他栈进行区分</p>
<p>（2）当一个函数被调用完后，程序会自动销毁掉该函数对应的栈空间</p>
<p><strong>函数形参调用</strong></p>
<p>（1）值传递（n1 int）</p>
<p>（2）引用传递（n1 *int）（地址拷贝，效率更高，其值传递数据越大，消耗越大）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func test1(n1 int)&#123;</span><br><span class="line">	n1 = n1 + 10</span><br><span class="line">	fmt.Println(n1)</span><br><span class="line">&#125;</span><br><span class="line">func test2(n1 *int)&#123;</span><br><span class="line">	*n1 = *n1 + 10</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	num := 20</span><br><span class="line">	test1(num)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">	test2(&amp;num)</span><br><span class="line">	fmt.Println(num)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（3）函数作为形参</p>
<p>以下abc函数作为myFun函数的形参传入</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func getSum(n1 int,n2 int)int&#123;</span><br><span class="line">	<span class="built_in">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line">// 当多个函数形参类型一致时可以修改（函数功能同上）</span><br><span class="line">//func getSum(n1,n2 int)int&#123;</span><br><span class="line">//	<span class="built_in">return</span> n1+n2</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">func myFun(abc func(int,int) int,num1 int, num2 int)int&#123;</span><br><span class="line">	<span class="built_in">return</span> abc(num1,num2)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	res := myFun(getSum,50,60)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可变函数：形参数量不预先预定，需要注意的是可变形参可以和固定形参一起使用，不过可变参数必须为形参列表的最后一项</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func sum(nums ...int) int&#123;</span><br><span class="line">	res := 0</span><br><span class="line">	<span class="keyword">for</span> _,v :=range nums&#123;</span><br><span class="line">		res+=v</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func sum2(nums ...int)int&#123;</span><br><span class="line">	sum := 0</span><br><span class="line">	<span class="keyword">for</span> i:=0;i&lt;len(nums);i++&#123;</span><br><span class="line">		sum+=nums[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    res := sum(1,2,3,4)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">	res2 := sum2(1,2,3,4)</span><br><span class="line">	fmt.Println(res2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="12-数组Array"><a href="#12-数组Array" class="headerlink" title="12.数组Array"></a>12.数组Array</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">// 数组的地址可以通过数组名获取，数组的地址也是第一个元素的地址，第二个元素的地址是第一个元素的地址+数组类型所占字节数（int占8字节）</span><br><span class="line">var a [3] int</span><br><span class="line">fmt.Printf(<span class="string">&quot;a的地址=%p,a[0]的地址=%p&quot;</span>,&amp;a,&amp;a[0]) //%p取变量地址</span><br><span class="line"></span><br><span class="line">var a [5]int</span><br><span class="line">fmt.Println(a)</span><br><span class="line">//声明int类型数组初始化为全0，Output:[0 0 0 0 0]</span><br><span class="line"></span><br><span class="line">// 赋值方法一</span><br><span class="line">b := [5]int&#123;1,2,3,4,5&#125;</span><br><span class="line">// 赋值方法二（不定义具体数量，固定三个点...）</span><br><span class="line">b := [...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">// 赋值方法三（下标1值为800，下标0值为900）</span><br><span class="line">b := [...]int&#123;1:800,0:900&#125;</span><br><span class="line">// 赋值方法四</span><br><span class="line">a[0] = 10</span><br><span class="line">a[1] = 20</span><br><span class="line"></span><br><span class="line">// 定义/声明二维数组</span><br><span class="line">var tD [2][3]int</span><br><span class="line"><span class="keyword">for</span> i:=0;i&lt;2;i++&#123;</span><br><span class="line">	 <span class="keyword">for</span> j:=0;j&lt;3;j++&#123;</span><br><span class="line">	 	tD[i][j] = i+j</span><br><span class="line">	 &#125;</span><br><span class="line">	 fmt.Println(tD)</span><br><span class="line">&#125;</span><br><span class="line">//二维数组直接初始化</span><br><span class="line">var tD [2][3]int = [2][3]int&#123;&#123;1,2,3&#125;,&#123;2,3,4&#125;&#125;</span><br><span class="line">// 或者</span><br><span class="line">var tD [2][3]int = [...][3]int&#123;&#123;1,2,3&#125;,&#123;2,3,4&#125;&#125;</span><br><span class="line">// 或者</span><br><span class="line">var tD = [2][3]int&#123;&#123;1,2,3&#125;,&#123;2,3,4&#125;&#125;</span><br><span class="line">// 或者</span><br><span class="line">var tD = [...][3]int&#123;&#123;1,2,3&#125;,&#123;2,3,4&#125;&#125;</span><br><span class="line">fmt.Println(tD)</span><br><span class="line"></span><br><span class="line">// 方式1 二维数组的遍历</span><br><span class="line"><span class="keyword">for</span> i:=0;i&lt;len(tD);i++&#123;</span><br><span class="line">	<span class="keyword">for</span> j:=0;j&lt;len(tD[i]);j++&#123;</span><br><span class="line">		fmt.Print(tD[i][j],<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line">// 方式2 二维数组的遍历</span><br><span class="line"><span class="keyword">for</span> _,v1:=range tD&#123;</span><br><span class="line">	<span class="keyword">for</span> _,v2:=range v1&#123;</span><br><span class="line">		fmt.Print(v2,<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a := [4]int&#123;1,2,3,4&#125;</span><br><span class="line">// 数组遍历一（注意格式化输出使用Printf）</span><br><span class="line"><span class="keyword">for</span> _,value := range a&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 数组遍历二</span><br><span class="line"><span class="keyword">for</span> i:=0;i&lt;len(a);i++&#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%d\t&quot;</span>,a[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 引用传递，修改数组的值</span><br><span class="line">func change(a *[4]int)&#123;//注意数组长度必须一致，也是数据类型的一部分</span><br><span class="line">	(*a)[0] = 88</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	a := [4]int&#123;1,2,3,4&#125;</span><br><span class="line">	change(&amp;a)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%v&quot;</span>,a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="13-分片Slices"><a href="#13-分片Slices" class="headerlink" title="13.分片Slices"></a>13.分片Slices</h1><p>关键字make() 只用于映射、切片和程道，不返回指针，即可以不初始化具体元素值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a := make([]string, 3)</span><br><span class="line">b := make([]string,len(a))</span><br><span class="line">copy(b,a)//复制数组</span><br><span class="line">// 数组分片</span><br><span class="line">c := [3]int&#123;1,2,3&#125;</span><br><span class="line">fmt.Println(c[1:])</span><br></pre></td></tr></table></figure>

<h1 id="14-集合Map"><a href="#14-集合Map" class="headerlink" title="14.集合Map"></a>14.集合Map</h1><p>关键字map实现键值对</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">m := make(map[string]int)</span><br><span class="line">m[<span class="string">&quot;k1&quot;</span>] = 7</span><br><span class="line">m[<span class="string">&quot;k2&quot;</span>] = 11</span><br><span class="line">fmt.Println(m)</span><br><span class="line">delete(m,<span class="string">&quot;k1&quot;</span>)//删除某键值对</span><br><span class="line">_, prs := m[<span class="string">&quot;k2&quot;</span>]//第二个返回值返回该键值是否存在，而第一个返回值不是关注内容，可用_代替</span><br><span class="line">fmt.Println(<span class="string">&quot;prs:&quot;</span>, prs)</span><br><span class="line">n := map[string]int&#123;<span class="string">&quot;foo&quot;</span>: 1, <span class="string">&quot;bar&quot;</span>: 2&#125;</span><br><span class="line">//定义map格式：map[key-type]value-type&#123;key-real:value-real&#125;</span><br></pre></td></tr></table></figure>

<h1 id="15-范围Range"><a href="#15-范围Range" class="headerlink" title="15.范围Range"></a>15.范围Range</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//int数组</span><br><span class="line">nums := []int&#123;2,3,4&#125;</span><br><span class="line"><span class="keyword">for</span> index,num := range nums&#123;</span><br><span class="line">	fmt.Println(index,num)</span><br><span class="line">&#125;</span><br><span class="line">//map集合（键值对）</span><br><span class="line">kvs := map[string]string&#123;<span class="string">&quot;a&quot;</span>: <span class="string">&quot;apple&quot;</span>, <span class="string">&quot;b&quot;</span>: <span class="string">&quot;banana&quot;</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v := range kvs &#123;</span><br><span class="line">	fmt.Printf(<span class="string">&quot;%s -&gt; %s\n&quot;</span>, k, v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="16-生成随机数"><a href="#16-生成随机数" class="headerlink" title="16.生成随机数"></a>16.生成随机数</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//表示生成0-99之间的数，但是每次生成为伪随机数，即多次重复运行均为同一值，因此需要提前设置一个种子，即Seed方法，返回1970.01.01 /00:00:00到此时的秒数/纳秒</span><br><span class="line">rand.Seed(time.Now().Unix())//秒数</span><br><span class="line">rand.Seed(time.Now().UnixNano())//秒数</span><br><span class="line">rand.Intn(100)</span><br></pre></td></tr></table></figure>

<h1 id="17-匿名函数"><a href="#17-匿名函数" class="headerlink" title="17.匿名函数"></a>17.匿名函数</h1><p>包含匿名函数的函数返回类型为func()，格式：func 函数名() func() 匿名函数返回类型{…}</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// 方式1：在main中定义匿名函数</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	res1 := func(n1 int,n2 int)int&#123;</span><br><span class="line">	<span class="built_in">return</span> n1+n2</span><br><span class="line">	&#125;(10,20)</span><br><span class="line">	fmt.Println(res1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式2：把匿名函数赋给一个变量（函数变量），再通过变量调用匿名函数</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	a:= func (n1 int,n2 int)int&#123;</span><br><span class="line">		<span class="built_in">return</span> n1 - n2</span><br><span class="line">	&#125;</span><br><span class="line">	res1 := a(10,30)</span><br><span class="line">	fmt.Println(<span class="string">&quot;res1=&quot;</span>,res1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式3：全局匿名函数：将匿名函数</span><br><span class="line">var (</span><br><span class="line">	fun1 = func(n1 int,n2 int)int&#123;</span><br><span class="line">		<span class="built_in">return</span> n1 + n2</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	res := fun1(1,2)</span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="18-指针"><a href="#18-指针" class="headerlink" title="18.指针"></a>18.指针</h1><p>指针类型：指针变量存的是一个地址，该地址指向的空间才是值，指针本身也有地址</p>
<p>int类型：int变量存的是一个int值（与指针类型作对比）</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var num int = 10</span><br><span class="line">fmt.Println(<span class="string">&quot;num的地址为：&quot;</span>,&amp;num)</span><br><span class="line"></span><br><span class="line">var ptr *int = &amp;num</span><br><span class="line">fmt.Println(<span class="string">&quot;ptr为：&quot;</span>,ptr)</span><br><span class="line">fmt.Println(<span class="string">&quot;ptr指向的值：&quot;</span>,*ptr)</span><br><span class="line"></span><br><span class="line">//解释var ptr *int = &amp;num</span><br><span class="line">//解释1：ptr是一个指针类型的变量</span><br><span class="line">//解释2：ptr类型是*int</span><br><span class="line">//解释3：ptr本身值维&amp;num</span><br><span class="line">//num = 10</span><br><span class="line">//ptr = num的存储地址</span><br><span class="line"></span><br><span class="line">//num的地址为： 0xc04203c1d0</span><br><span class="line">//ptr为： 0xc04203c1d0</span><br><span class="line">//ptr指向的值： 10</span><br></pre></td></tr></table></figure>

<p>*变量名表示该变量的指针，&amp;变量名读取变量的内存地址（即地址），例如示范代码中int类型变量i值为1，&amp;i表示变量i的内存地址，在zeroptr函数中形参为指针类型，</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func zeroptr(iptr *int) &#123;</span><br><span class="line">	*iptr = 0</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	i := 1</span><br><span class="line">	zeroptr(&amp;i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习1：获取一个int变量num的地址并显示</p>
<p>练习2：将num地址赋给ptr并通过ptr修改num值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var num int = 20</span><br><span class="line">var ptr1 *int = &amp;num</span><br><span class="line">fmt.Println(ptr1)</span><br><span class="line"></span><br><span class="line">*ptr1 = 30</span><br><span class="line">fmt.Println(num)</span><br></pre></td></tr></table></figure>

<h1 id="19-运算符"><a href="#19-运算符" class="headerlink" title="19.运算符%"></a>19.运算符%</h1><p>a % b = a - a / b * b</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 % 3 = 1</span><br><span class="line">-10 % 3 = -10 - (-10) / 3 * 3 = -10 +9 = -1</span><br><span class="line">10 % -3 = 1</span><br><span class="line">-10 % -3 = -1</span><br></pre></td></tr></table></figure>

<h1 id="20-逻辑与-或"><a href="#20-逻辑与-或" class="headerlink" title="20.逻辑与/或"></a>20.逻辑与/或</h1><p>不仅可以针对变量值判断之外，还可以对函数返回值作为逻辑与/或的判断</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="built_in">test</span>() bool&#123;</span><br><span class="line">	<span class="built_in">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="function"><span class="title">test</span></span>() &#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;true&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="21-结构体及方法"><a href="#21-结构体及方法" class="headerlink" title="21.结构体及方法"></a>21.结构体及方法</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> person struct &#123;</span><br><span class="line">	name string</span><br><span class="line">	age  int</span><br><span class="line">	sex string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func newPerson(name string,age int) person&#123;</span><br><span class="line">	p:= person&#123;name:name,age:age&#125;</span><br><span class="line">	p.sex = <span class="string">&quot;male&quot;</span></span><br><span class="line">	<span class="built_in">return</span> p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	fmt.Println(newPerson(<span class="string">&quot;John&quot;</span>,18))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体方法格式：func (结构体名 结构体类型) 方法名() 返回类型{…}</p>
<p>Tips：结构体方法中对结构体类型前是否添加*对结果不影响</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> rect struct &#123;</span><br><span class="line">	width, height int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (r rect) area() int &#123;</span><br><span class="line">	<span class="built_in">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 使用*结构体类型效果一致</span><br><span class="line">//func (r *rect) area() int &#123;</span><br><span class="line">//    <span class="built_in">return</span> r.width * r.height</span><br><span class="line">//&#125;</span><br><span class="line"></span><br><span class="line">func (r rect) perim() int &#123;</span><br><span class="line">	<span class="built_in">return</span> 2*r.width + 2*r.height</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	r := rect&#123;width: 10, height: 5&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;area: &quot;</span>, r.area())</span><br><span class="line">	fmt.Println(<span class="string">&quot;perim:&quot;</span>, r.perim())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="22-错误Error"><a href="#22-错误Error" class="headerlink" title="22.错误Error"></a>22.错误Error</h1><p>在Go中，通过显式的、单独的返回值来传递错误是常见的现象，首先需要导入”error”，在函数返回类型添加error，</p>
<p>补充：nil在Go中表示空值</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func f1(arg int) (int, error) &#123;</span><br><span class="line">	<span class="keyword">if</span> arg &gt; 100 &#123;</span><br><span class="line">		<span class="built_in">return</span> -1, errors.New(<span class="string">&quot;more than 100&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> arg, nil</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">	fmt.Println(f1(120))</span><br><span class="line">	fmt.Println(f1(90))</span><br><span class="line">&#125;</span><br><span class="line">//Output: -1 more than 100</span><br><span class="line">//Output: 90 &lt;nil&gt;</span><br></pre></td></tr></table></figure>

<h1 id="23-获取用户终端输入"><a href="#23-获取用户终端输入" class="headerlink" title="23.获取用户终端输入"></a>23.获取用户终端输入</h1><p>调用fmt包中的fmt.Scanf和fmt.Scanln，其中fmt.Scanln表示读取一行数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 方式一：使用Scanln</span><br><span class="line">var name string</span><br><span class="line">var age int</span><br><span class="line">fmt.Println(<span class="string">&quot;input your name:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;name)//传入变量的地址（引用传递），则函数内的值会影响函数外的变量值，使用name无法执行该语句</span><br><span class="line">fmt.Println(<span class="string">&quot;input your age:&quot;</span>)</span><br><span class="line">fmt.Scanln(&amp;age)//传入变量的地址（引用传递），则函数内的值会影响函数外的变量值</span><br><span class="line">fmt.Println(name,age)</span><br><span class="line"></span><br><span class="line">// 方式二：使用Scanf</span><br><span class="line">fmt.Println(<span class="string">&quot;Input your name,age by spacing off&quot;</span>)</span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s %d&quot;</span>,&amp;name,&amp;age)</span><br><span class="line">fmt.Println(name,age)</span><br></pre></td></tr></table></figure>

<h1 id="24-进制输出"><a href="#24-进制输出" class="headerlink" title="24.进制输出"></a>24.进制输出</h1><p>八进制：以数字0开头表示；</p>
<p>十六进制：以数字0x或者0X开头表示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 二进制(使用格式化输出用Printf)</span><br><span class="line">var i int = 5</span><br><span class="line">fmt.Printf(<span class="string">&quot;%b\n&quot;</span>,i)</span><br><span class="line">// 八进制</span><br><span class="line">var j int = 011</span><br><span class="line">fmt.Println(<span class="string">&quot;j=&quot;</span>,j)</span><br><span class="line">// 十六进制</span><br><span class="line">var m int = 0x11</span><br><span class="line">fmt.Println(<span class="string">&quot;m=&quot;</span>,m)</span><br></pre></td></tr></table></figure>

<h1 id="25-原码、反码、补码"><a href="#25-原码、反码、补码" class="headerlink" title="25.原码、反码、补码"></a>25.原码、反码、补码</h1><p>1）二进制最高位是符号位：0表示正数，1表示负数</p>
<blockquote>
<p>例如：1=&gt;[0000 0001] -1=&gt;[1000 0001]</p>
</blockquote>
<p>2）正数的原码、反码、补码相同</p>
<p>3）负数的反码 = 原码符号位不变，其他位数取反</p>
<blockquote>
<p>例如：1=&gt;原码、反码、补码 [0000 0001]</p>
<p>-1=&gt;原码[1000 0001]，反码[1111 1110]，补码[1111 1111]（下一性质）</p>
</blockquote>
<p>4）负数的补码 = 反码 + 1</p>
<p>5）0的反码、补码 = 0</p>
<p>6）计算机运算时以补码方式运算</p>
<h1 id="26-移位运算"><a href="#26-移位运算" class="headerlink" title="26.移位运算"></a>26.移位运算</h1><p>右移运算符&gt;&gt;：低位溢出，符号位不变，使用符号位补溢的高位</p>
<p>左移运算符&lt;&lt;：符号位不变，低位补0</p>
<blockquote>
<p>例如：1&gt;&gt;2 // 0000 0001 =&gt; 0000 0000 = 0</p>
<p>例如：1&lt;&lt;2 // 0000 0001 =&gt; 0000 0100 = 4（左移2位）</p>
</blockquote>
<h1 id="27-自定义数据类型"><a href="#27-自定义数据类型" class="headerlink" title="27.自定义数据类型"></a>27.自定义数据类型</h1><p>基本语法：type 自定义数据类型 数据类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> myInt int //myInt等价于int</span><br><span class="line"></span><br><span class="line">// 自定义函数类型</span><br><span class="line"></span><br><span class="line">// 1.定义函数</span><br><span class="line">func getSum(n1 int,n2 int)int&#123;</span><br><span class="line">	<span class="built_in">return</span> n1+n2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 2.自定义函数类型</span><br><span class="line"><span class="built_in">type</span> myFunType func(int,int)int</span><br><span class="line"></span><br><span class="line">// 3.将定义函数作为另一个函数的形参</span><br><span class="line">func myFun(abc myFunType,num1 int, num2 int)int&#123;</span><br><span class="line">	<span class="built_in">return</span> abc(num1,num2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 4.主函数：调用函数</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	res := myFun(getSum,50,60)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="28-init函数"><a href="#28-init函数" class="headerlink" title="28.init函数"></a>28.init函数</h1><p>每一个源文件都有一个init函数，当声明init函数和main函数时，init优先执行，通常在init完成初始化工作，如果文件中包含全局变量定义、init函数、main函数时，执行流程：变量定义-&gt;init函数-&gt;main函数</p>
<h1 id="29-闭包"><a href="#29-闭包" class="headerlink" title="29.闭包"></a>29.闭包</h1><p>闭包：是一个函数与其相关的引用环境组合的一个整体（实体）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line">func myfunc() func(int) int &#123;</span><br><span class="line">	var n int = 10</span><br><span class="line">	<span class="built_in">return</span> func(i int) int &#123;</span><br><span class="line">		n = n + i</span><br><span class="line">		<span class="built_in">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	nextInt := myfunc()</span><br><span class="line">	fmt.Println(nextInt(1))// 10 + 1</span><br><span class="line">	fmt.Println(nextInt(2))// 11 + 2（主要原因在于myfunc中的变量n并不是每一次均被初始化，而是原基础变化）</span><br><span class="line">	fmt.Println(nextInt(3))// 13 + 3</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Output:</span><br><span class="line">//11</span><br><span class="line">//13</span><br><span class="line">//16</span><br><span class="line"></span><br><span class="line">其中myfunc返回的是fun (int) int，返回的是一个匿名函数，匿名函数引用到函数外的变量n，共同构成了整体</span><br></pre></td></tr></table></figure>

<p>练习：</p>
<p>（1）编写一个函数makeSuffix（suffix string）可接收一个文件后缀名（比如.jpg），并返回一个闭包</p>
<p>（2）调用闭包，可传入一个文件名，如果该文件名没有指定的后缀（比如.jpg），则返回文件名.jpg，如果有.jpg后缀，则返回原文件名</p>
<p>（3）要求使用闭包方式完成</p>
<p>（4）strings.HasSuffix可以判断某个字符串是否有指定的后缀</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func makeSuffix(suffix string) func(string) string&#123;</span><br><span class="line">	<span class="built_in">return</span> func (name string) string&#123;</span><br><span class="line">		// 如果name没有指定后缀，则加上，否则返回原来的名字</span><br><span class="line">		<span class="keyword">if</span> strings.HasSuffix(name,suffix)&#123;</span><br><span class="line">			<span class="built_in">return</span> name</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">return</span> name + suffix</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	f := makeSuffix(<span class="string">&quot;.jpg&quot;</span>)</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件名处理后=&quot;</span>,f(<span class="string">&quot;winter&quot;</span>))</span><br><span class="line">	fmt.Println(<span class="string">&quot;文件名处理后=&quot;</span>,f(<span class="string">&quot;bird.jpg&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">//返回函数与变量suffix组合成一个闭包，返回函数引用变量suffix</span><br><span class="line">//闭包优势在于仅需要输入一次suffix（后缀）即可</span><br></pre></td></tr></table></figure>

<h1 id="30-函数关键字-defer"><a href="#30-函数关键字-defer" class="headerlink" title="30.函数关键字-defer"></a>30.函数关键字-defer</h1><p>通常需要创建资源（例如：数据库连接、文件句柄、锁等），为了函数执行后及时释放资源，Go中提供了defer（延时机制）</p>
<p>（1）当执行defer时，暂时不执行，且会将defer后语句压入独立的栈（defer栈），当函数执行后才按照先入后出的方式执行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func sum(n1 int,n2 int)int&#123;</span><br><span class="line">	defer fmt.Println(<span class="string">&quot;n1=&quot;</span>,n1)</span><br><span class="line">	defer fmt.Println(<span class="string">&quot;n2=&quot;</span>,n2)</span><br><span class="line">	n1++</span><br><span class="line">	n2++</span><br><span class="line">	res := n1 + n2</span><br><span class="line">	fmt.Println(<span class="string">&quot;res=&quot;</span>,res)</span><br><span class="line">	<span class="built_in">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()  &#123;</span><br><span class="line">	sum(10,20)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回结果： res=32、n2=20、n1=10</span><br><span class="line">// 原因在于在n1++、n2++前已经压入defer栈</span><br></pre></td></tr></table></figure>

<p>（2）及时释放函数创建的资源（模拟代码）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">	file = openfile(<span class="string">&quot;文件名&quot;</span>)</span><br><span class="line">	defer file.close()</span><br><span class="line">	//其他代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">	connect = openDatabase()</span><br><span class="line">	defer connect.close()</span><br><span class="line">	//其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="31-系统常用函数——字符串"><a href="#31-系统常用函数——字符串" class="headerlink" title="31.系统常用函数——字符串"></a>31.系统常用函数——字符串</h1><table>
<thead>
<tr>
<th>序号</th>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>len(str)</td>
<td>统计字符串长度</td>
</tr>
<tr>
<td>2</td>
<td>r :=[]rune(str)</td>
<td>转切片，字符串遍历，同时解决中文问题，需要重新定义变量</td>
</tr>
<tr>
<td>3</td>
<td>n,err := strconv.Atoi[“12”]</td>
<td>字符串转整数</td>
</tr>
<tr>
<td>4</td>
<td>str := strconv.Itoa(1234)</td>
<td>整数转字符串</td>
</tr>
<tr>
<td>5</td>
<td>var bytes = []byte(“hello go”)</td>
<td>字符串转[]byte</td>
</tr>
<tr>
<td>6</td>
<td>str := string([]byte{1,2,3})</td>
<td>[]byte转字符串</td>
</tr>
<tr>
<td>7</td>
<td>str := strconv.FormatInt(123,2)</td>
<td>10进制转2,8,16进制，返回对应的字符串</td>
</tr>
<tr>
<td>8</td>
<td>strings.Contains(“sea”,”food”)</td>
<td>查找子串是否在指定的字符串</td>
</tr>
<tr>
<td>9</td>
<td>strings.Count(“cheese”,”e”)</td>
<td>统计一个字符串有几个指定的不重复的子串</td>
</tr>
<tr>
<td>10</td>
<td>fmt.Println(strings.EqualFold(“abc”,”ABC”))</td>
<td>不区分大小写的字符串比较（==区分大小写）</td>
</tr>
<tr>
<td>11</td>
<td>strings.Index(“NLT_ABC”,”abc”)</td>
<td>返回子串在字符串第一次出现的index值</td>
</tr>
<tr>
<td>12</td>
<td>strings.LastIndex(“go golang”,”go”)</td>
<td>返回子串在字符串最后一次index</td>
</tr>
<tr>
<td>13</td>
<td>strings.Replace(“go go hello”,”go”,”go语言”,n)</td>
<td>n可以指定你希望替换几个，如果n=-1全部替换，注意不会替换原字符串，而是返回一个新的字符串</td>
</tr>
<tr>
<td>14</td>
<td>strings.Split(“hello,world,ok”,”,”)</td>
<td>将一个字符串拆分成字符串数组，返回新数组</td>
</tr>
<tr>
<td>15</td>
<td>strings.ToLower(“Go”)</td>
<td>将字符串的字母进行大小写转换</td>
</tr>
<tr>
<td>16</td>
<td>strings.TrimSpace(“ abc aa “)</td>
<td>将字符串左右两边的空格去掉</td>
</tr>
<tr>
<td>17</td>
<td>strings.TrimLeft(“! hello!”,”!”)</td>
<td>将字符串左边指定的字符去掉//左边!和“ ”去掉</td>
</tr>
<tr>
<td>18</td>
<td>strings.TrimRight(“! hello!”,”!”)</td>
<td>将字符串右边指定的字符去掉//右边!和“ ”去掉</td>
</tr>
<tr>
<td>19</td>
<td>strings.HasPrefix(“ftp://“,”ftp”)</td>
<td>判断字符串是否以指定字符串开头</td>
</tr>
<tr>
<td>20</td>
<td>strings.HasSuffix(“ABac”,”AB”)</td>
<td>判断字符串是否以指定字符串结尾</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 3. 字符串转整数</span><br><span class="line">n,err := strconv.Atoi(<span class="string">&quot;123&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err!= nil&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;转换错误&quot;</span>,err)</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	fmt.Println(n)</span><br><span class="line">&#125;</span><br><span class="line">//如果非整数则返回：转换错误 strconv.Atoi: parsing <span class="string">&quot;z123&quot;</span>: invalid syntax</span><br><span class="line"></span><br><span class="line">// 4. 整数转字符串 </span><br><span class="line">str := strconv.Itoa(12345)</span><br><span class="line">fmt.Printf(<span class="string">&quot;str=%v,type=%T&quot;</span>,str,str)</span><br><span class="line"></span><br><span class="line">// 补充格式化输出</span><br><span class="line">%v	表示按照相应的默认格式</span><br><span class="line">%T	相应值的类型</span><br><span class="line">%t	布尔值 <span class="literal">true</span> 或 <span class="literal">false</span></span><br><span class="line">%b	二进制表示</span><br><span class="line">%c	相应 Unicode 码点所表示的字符</span><br><span class="line">%d	十进制表示</span><br><span class="line">%o	八进制表示</span><br><span class="line">%x	十六进制表示，字母形式为小写 a-f</span><br><span class="line">%X	十六进制表示，字母形式为大写 A-F</span><br><span class="line">%e	科学计数法，例如 -1234.456e+78</span><br><span class="line">%E	科学计数法，例如 -1234.456E+78</span><br><span class="line">%f	有小数点而无指数，例如 123.456</span><br><span class="line">%s	字符串或切片的无解译字节</span><br><span class="line"></span><br><span class="line">// 5.字符串转[]byte（byte的%v输出是对应的ASCII码）</span><br><span class="line">var bytes = []byte(<span class="string">&quot;hello go&quot;</span>)</span><br><span class="line"></span><br><span class="line">// 13.n可以指定你希望替换几个，如果n=-1全部替换</span><br><span class="line">strings.Replace(<span class="string">&quot;go go hello&quot;</span>,<span class="string">&quot;go&quot;</span>,<span class="string">&quot;go语言&quot;</span>,n)</span><br></pre></td></tr></table></figure>

<h1 id="32-时间和日期相关函数"><a href="#32-时间和日期相关函数" class="headerlink" title="32.时间和日期相关函数"></a>32.时间和日期相关函数</h1><p>需要提前导入time包</p>
<p>时间的常量：</p>
<table>
<thead>
<tr>
<th>时间常量</th>
<th>定义</th>
</tr>
</thead>
<tbody><tr>
<td>Nanosecond</td>
<td>纳秒</td>
</tr>
<tr>
<td>Microsecond</td>
<td>微秒</td>
</tr>
<tr>
<td>Millisecond</td>
<td>毫秒</td>
</tr>
<tr>
<td>Second</td>
<td>秒</td>
</tr>
<tr>
<td>Minute</td>
<td>分钟</td>
</tr>
<tr>
<td>Hour</td>
<td>小时</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//获取当前时间，分别获得年月日时分秒：now.Year()/Month()/Day()/Hour()/Minute()/Second()</span><br><span class="line">now := time.Now()</span><br><span class="line">fmt.Println(now)//2019-11-12 18:38:40.4767544 +0800 CST</span><br><span class="line">fmt.Println(now.Year())//2019</span><br><span class="line">fmt.Println(now.Month())//Novemeber</span><br><span class="line">fmt.Println(int(now.Month()))//11</span><br><span class="line"></span><br><span class="line">// 每隔0.1秒打印一个数字</span><br><span class="line">i := 0</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">	i++</span><br><span class="line">	fmt.Println(i)</span><br><span class="line">	time.Sleep(time.Millisecond*100)</span><br><span class="line">	<span class="keyword">if</span> i == 100&#123;//10秒后退出</span><br><span class="line">		<span class="built_in">break</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Unix和UnixNano的使用</span><br><span class="line">fmt.Printf(<span class="string">&quot;unix时间戳=%v,unixnano时间戳=%v&quot;</span>,now.Unix(),now.UnixNano())</span><br><span class="line"></span><br><span class="line">// 统计函数执行时间</span><br><span class="line">func <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">	str := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> i:=0;i&lt;100000;i++ &#123;</span><br><span class="line">		str += <span class="string">&quot;hello&quot;</span> + strconv.Itoa(i) //备注：strconv.Itoa()表示将整数转为字符串</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	start := time.Now().Unix()</span><br><span class="line">	<span class="built_in">test</span>()</span><br><span class="line">	end := time.Now().Unix()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;执行test()耗费时间%v&quot;</span>,(end-start))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="33-内置函数"><a href="#33-内置函数" class="headerlink" title="33.内置函数"></a>33.内置函数</h1><table>
<thead>
<tr>
<th>函数名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>new</td>
<td>分配内存，主要分配值类型，int,float32,struct，返回指针</td>
</tr>
<tr>
<td>make</td>
<td>分配内存，主要分配引用类型，char,map,slice</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	num1 := 100</span><br><span class="line">	fmt.Printf(<span class="string">&quot;num1类型:%T,num1值:%v,num1的地址:%v\n&quot;</span>,num1,num1,&amp;num1)</span><br><span class="line">	num2 := new(int)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;num2类型:%T,num2值:%v,num2的地址:%v,num2指向的值:%v&quot;</span>,num2,num2,&amp;num2,*num2)</span><br><span class="line">&#125;</span><br><span class="line">//因此new有2个子过程：其一分配指针内存空间，其二再指向一个默认值</span><br></pre></td></tr></table></figure>

<h1 id="34-错误-异常的捕获和处理"><a href="#34-错误-异常的捕获和处理" class="headerlink" title="34.错误/异常的捕获和处理"></a>34.错误/异常的捕获和处理</h1><p>Go中错误（panic）程序会退出（奔溃）<br>Go引用的处理方式：defer,panic,recover<br>Go可以抛出一个panic的异常，在defer中通过recover捕获这个异常，再正常处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">test</span></span>()&#123;</span><br><span class="line">	// 使用defer + recover捕获和处理异常</span><br><span class="line">	defer <span class="function"><span class="title">func</span></span>()&#123;//匿名函数</span><br><span class="line">		err := recover() // recover()内置函数，可以捕获异常</span><br><span class="line">		<span class="keyword">if</span> err != nil&#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;err=&quot;</span>,err)</span><br><span class="line">			// 通常该函数的负责员（保证了主函数的执行）</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">	num1 := 10</span><br><span class="line">	num2 := 0</span><br><span class="line">	res := num1 / num2</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	<span class="built_in">test</span>()</span><br><span class="line">	fmt.Println(<span class="string">&quot;执行test()&quot;</span>)//使用了defer+recover后仍可以执行该句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Go也支持自定义错误，使用errors.New和panic内置函数<br>1）errors.New(“错误说明”)，会返回一个error类型的值，表示一个错误<br>2）panic内置函数，接收一个interface{}类型的值作为参数，可以接收error类型的变量，输出错误信息，并退出程序</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func <span class="function"><span class="title">test2</span></span>()&#123;</span><br><span class="line">	err := readConf(<span class="string">&quot;config.ini&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err !=nil&#123;</span><br><span class="line">		//发生错误并输出错误，终止程序！</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;执行完test2()&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="35-四舍五入"><a href="#35-四舍五入" class="headerlink" title="35.四舍五入"></a>35.四舍五入</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h1 := 27.0</span><br><span class="line">h2 := 5.0</span><br><span class="line">h3 := fmt.Sprintf(<span class="string">&quot;%.2f&quot;</span>,h1/h2)//保留2位小数</span><br><span class="line">fmt.Printf(<span class="string">&quot;h3 = %v&quot;</span>,h3)</span><br></pre></td></tr></table></figure>

<h1 id="36-切片Slice"><a href="#36-切片Slice" class="headerlink" title="36.切片Slice"></a>36.切片Slice</h1><p>（1）切片是数组的引用，切片是引用类型，在进行传递时，遵守引用传递的机制</p>
<p>（2）切片的使用和数组类似，遍历切片和访问切片的元素、求切片长度都是一样</p>
<p>（3）切片长度可以变换，即动态变换数组</p>
<p>（4）定义基本语法：var 变量名 [] 类型</p>
<p>（5）切片结构：</p>
<table>
<thead>
<tr>
<th>指向数组的地址</th>
<th>长度</th>
<th>容量</th>
</tr>
</thead>
<tbody><tr>
<td>address(eg.0x0011)</td>
<td>len</td>
<td>cap</td>
</tr>
</tbody></table>
<p>声明/定义切片三个方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// 方式一：定义一个切片，让切片引用已经创建好的数组</span><br><span class="line">var myarr [5] int = [...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">myslice := myarr[1:3] // 引用myarr数组的第2个元素到第3个元素（左闭右开），即myarr[1]和myarr[2]</span><br><span class="line">fmt.Println(myslice)</span><br><span class="line">fmt.Println(<span class="string">&quot;切片容量：&quot;</span>,<span class="built_in">cap</span>(myslice))//切片容量是动态变化，<span class="built_in">cap</span>全称为capability，<span class="built_in">cap</span>容量取决于具体类型，其中切片容量一般是底层数组长度的两倍</span><br><span class="line">// 切片由3部分组成：（1）指向数组的指针（2）切片长度（3）切片容量</span><br><span class="line"></span><br><span class="line">// 方式二：通过make创建切片</span><br><span class="line">// 基本语法：var 切片名 [] <span class="built_in">type</span> = make([]<span class="built_in">type</span>,len,[<span class="built_in">cap</span>])</span><br><span class="line">// 其中<span class="built_in">type</span>数据类型 len大小 <span class="built_in">cap</span>指定切片容量</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var myslice [] int = make([]int,4)// <span class="built_in">cap</span>&gt;len</span><br><span class="line">	fmt.Println(myslice)// 默认值为[0 0 0 0]</span><br><span class="line">	fmt.Println(<span class="string">&quot;slice len=&quot;</span>,len(myslice),<span class="string">&quot;slice cap=&quot;</span>,<span class="built_in">cap</span>(myslice))// slice len= 4 slice <span class="built_in">cap</span>= 4</span><br><span class="line">	myslice[0] = 100</span><br><span class="line">	myslice[2] = 200</span><br><span class="line">	fmt.Println(myslice)// [100 0 200 0]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方式三：定义一个切片，直接指定具体数组，使用原理类似make</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var myslice [] int = []int &#123;1,3,5&#125;</span><br><span class="line">	fmt.Println(myslice)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>区分：</p>
<p>方式1：是直接引用数组，该数组是预先存在的，程序员可见，数组和切片均可访问<br>方式2：通过make创建切片，make会创建一个数组，由切片在底层进行维护，程序员不可见，切片存放的指针指向内部创建的数组空间的第一个元素，只能通过切片访问元素</p>
<p>切片的遍历</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var myarr [5]int = [...]int&#123;1,2,3,4,5&#125;</span><br><span class="line">var myslice = myarr[1:3]</span><br><span class="line">// 方式1 <span class="keyword">for</span>循环</span><br><span class="line"><span class="keyword">for</span> i:=0;i&lt;len(myslice);i++&#123;</span><br><span class="line">		fmt.Println(myslice[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//方式2 for-range</span><br><span class="line"><span class="keyword">for</span> _,value:=range myslice&#123;</span><br><span class="line">	fmt.Println(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>切片简写：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var myslice = myarr[0:end] =&gt; var myslice = myarr[:end]</span><br><span class="line">var myslice = myarr[start:len(arr)] =&gt; var myslice = myarr[start:?]</span><br><span class="line">var myslice = myarr[0:len(arr)] =&gt; var myslice = myarr[:]</span><br></pre></td></tr></table></figure>

<p>（1）cap是一个内置函数，用于统计切片容量，即最大可存放多少个元素<br>（2）切片定义完后不能使用，因为本身为空的，需要让其引用一个数组，或者make一个空间供切片使用<br>（3）切片可继续切片<br>（4）用append内置函数可以对切片动态追加，若切片有足够的容量，其目标会重新切片以容纳新的元素，否则会分配一个新的基本数组，append返回更新后的切片，因此必须存储追加后的结果，注意需要重新赋给切片</p>
<p>在切片上追加元素/切片：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myslice [] int = []int&#123;1,2,3&#125;//定义切片</span><br><span class="line">fmt.Println(myslice)</span><br><span class="line">myslice = append(myslice,4,5,6) // 追加元素</span><br><span class="line">myslice = append(myslice,myslice...) // 追加切片（注意要加...，另外仅能添加切片，不能添加数组）</span><br><span class="line">fmt.Println(myslice)</span><br></pre></td></tr></table></figure>

<p>切片append操作的底层原理分析：<br>（1）切片append操作的本质是对数组扩容<br>（2）go底层会创建新的数组newArr<br>（3）将slice原来包含的元素拷贝到新的数组newArr<br>（4）slice重新引用到newArr<br>（5）newArr是在底层维护，程序员不可见</p>
<p>切片的拷贝操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var myslice1 []int = []int&#123;1,2,3,4,5&#125;</span><br><span class="line">var myslice2 = make([]int,10)//定义一个长度为10的切片</span><br><span class="line">copy(myslice2,myslice1)//把myslice1拷贝给myslice2</span><br><span class="line">fmt.Println(myslice1)//[1 2 3 4 5]</span><br><span class="line">fmt.Println(myslice2)//[1 2 3 4 5 0 0 0 0 0]</span><br><span class="line">// 注意myslice1和myslice2的空间是独立的，即修改myslice1的元素不会影响myslice2</span><br></pre></td></tr></table></figure>

<p>在拷贝（copy）过程中，如果slice的长度不够时，会依据slice的真实长度拷贝对应长度，不会因为长度不够而报错</p>
<p>例如：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a[]int = []int&#123;1,2,3,4,5&#125;</span><br><span class="line">var myslice = make([]int,1)</span><br><span class="line">fmt.Println(a)//[1 2 3 4 5]</span><br><span class="line">copy(myslice,a)</span><br><span class="line">fmt.Println(myslice)//[1]</span><br></pre></td></tr></table></figure>

<p>切片是引用类型，因此在传递过程中，遵守引用机制</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func <span class="built_in">test</span>(myslice []int)&#123;</span><br><span class="line">	myslice[0] = 100</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var myslice[]int = []int&#123;1,2,3,4,5&#125;</span><br><span class="line">	fmt.Println(myslice)//[1 2 3 4 5]</span><br><span class="line">	<span class="built_in">test</span>(myslice)</span><br><span class="line">	fmt.Println(myslice)//[100 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>string底层是byte数组，因此string可进行切片处理</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mystr := <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">myslice := mystr[5:]</span><br><span class="line">fmt.Println(myslice)//world</span><br></pre></td></tr></table></figure>

<p>string是不可变数据结构，不能赋值具体元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mystr[0] = <span class="string">&#x27;a&#x27;</span>// × 编译失败 error 无法赋值</span><br></pre></td></tr></table></figure>

<p>需要修改string可以通过先将string -&gt; [] byte 或者 []rune -&gt; 修改 -&gt; 重转成string</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mystr := <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">arr := []byte(mystr)</span><br><span class="line">arr[0] = <span class="string">&#x27;a&#x27;</span></span><br><span class="line">mystr = string(arr)</span><br><span class="line">fmt.Println(mystr)//aelloworld</span><br></pre></td></tr></table></figure>

<p>但是以上方法仅能处理英语和数字，不能处理中文，1个byte按照1个字节处理，但一个汉字占3个字节，解决办法将string转成[]rune，按照字符处理，兼容汉字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mystr := <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">arr := []rune(mystr)</span><br><span class="line">arr[0] = <span class="string">&#x27;汉&#x27;</span></span><br><span class="line">mystr = string(arr)</span><br><span class="line">fmt.Println(mystr)</span><br></pre></td></tr></table></figure>

<p>斐波拉契数列（每个元素为前两个元素之和，第一个和第二个元素均为1）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func fbn(n int)([]int)&#123;</span><br><span class="line">	myslice := make([]int,n)</span><br><span class="line">	myslice[0],myslice[1] = 1,1</span><br><span class="line">	<span class="keyword">for</span> i:=2;i&lt;n;i++&#123;</span><br><span class="line">		myslice[i] = myslice[i-1] + myslice[i-2]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">return</span> myslice</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	myfbn := fbn(10)</span><br><span class="line">	fmt.Println(myfbn)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="37-排序"><a href="#37-排序" class="headerlink" title="37.排序"></a>37.排序</h1><p>排序分类：</p>
<p>（1）内部排序：将需要处理的所有数据加载在内存存储器进行排序（交换式排序、选择式排序、插入式排序）</p>
<p>交换式排序：冒泡排序、快速排序</p>
<p>（2）外部排序：数据量过大时无法全部加载到内存，需要借助外部存储进行排序（合并排序、直接合并排序）</p>
<p>冒泡排序实战：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func BubbleSort(arr *[5]int)&#123;</span><br><span class="line">	<span class="keyword">for</span> i:=0;i&lt;len(arr)-1;i++&#123;</span><br><span class="line">		<span class="keyword">for</span> j:=i+1;j&lt;len(arr);j++&#123;</span><br><span class="line">			<span class="keyword">if</span> (*arr)[i]&gt;(*arr)[j]&#123;</span><br><span class="line">				arr[i],arr[j] = arr[j],arr[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	arr := [5]int&#123;2,3,1,5,4&#125;// 定义数组</span><br><span class="line">	BubbleSort(&amp;arr)</span><br><span class="line">	fmt.Println(arr)//[1 2 3 4 5]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找实战（必须是有序数组）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">func binaryfind(arr *[7]int,leftindex int, rightindex int,target int)&#123;</span><br><span class="line">	// 判断leftindex是否大于rightindx</span><br><span class="line">	<span class="keyword">if</span> leftindex &gt; rightindex&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;找不到该元素&quot;</span>)</span><br><span class="line">		<span class="built_in">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	mid := (leftindex+rightindex)/2</span><br><span class="line">	<span class="keyword">if</span> (*arr)[mid] &gt; target&#123;</span><br><span class="line">		binaryfind(arr,leftindex,mid-1,target)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (*arr)[mid] &lt; target&#123;</span><br><span class="line">		binaryfind(arr,mid+1,rightindex,target)</span><br><span class="line">	&#125;<span class="keyword">else</span> <span class="keyword">if</span> (*arr)[mid] == target&#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;找到该元素，下标为%v&quot;</span>,mid)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	arr := [7]int&#123;1,2,3,4,5,6,7&#125;</span><br><span class="line">	binaryfind(&amp;arr,0,6,14)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="38-map字段"><a href="#38-map字段" class="headerlink" title="38.map字段"></a>38.map字段</h1><p>map是key-value数据结构，又称为字段或者关联数组，类似于其他编程语言的集合/字典，</p>
<p>基本语法：var map 变量名 map[keytype] valuetype</p>
<p>key类型：int 、bool、string、指针、channel、接口、结构体、数组</p>
<p>key不支持的类型：切片、map、函数（无法使用==判断）</p>
<p>声明map不会分配内存，初始化需要value，分配内存后才可以赋值和使用</p>
<p>Tip1：key值不可以重复</p>
<p>Tip2：value值可重复</p>
<p>Tip3：make-value是无序的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//方式一：声明 + 分配</span><br><span class="line">var a map[string]string// 声明</span><br><span class="line">a = make(map[string]string,10)// 分配数据空间（其中第2个参数表示该map可以存放10个key-value）</span><br><span class="line">//方式二：声明分配</span><br><span class="line">a := make(map[string]string)</span><br><span class="line">a[<span class="string">&quot;num1&quot;</span>] = <span class="string">&quot;张三&quot;</span>//初始化</span><br><span class="line">a[<span class="string">&quot;num2&quot;</span>] = <span class="string">&quot;李四&quot;</span></span><br><span class="line">fmt.Println(a)// map[num1:张三 num2:李四]</span><br><span class="line">//方式三：声明分配初始化</span><br><span class="line">var cities map[string]string = map[string]string&#123;</span><br><span class="line">	<span class="string">&quot;num1&quot;</span>:<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	<span class="string">&quot;num2&quot;</span>:<span class="string">&quot;深圳&quot;</span>,//注意最后一项也要添加<span class="string">&quot;,&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(cities)</span><br></pre></td></tr></table></figure>

<p>练习题：建立一个学生信息Map，存放3个学生信息，每个学生信息有name和sex信息，即嵌套map</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">studentMap := make(map[string]map[string]string)//key类型为string，value类型为map</span><br><span class="line">studentMap[<span class="string">&quot;stu01&quot;</span>] = make(map[string]string,2)</span><br><span class="line">studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;Male&quot;</span></span><br><span class="line"></span><br><span class="line">studentMap[<span class="string">&quot;stu02&quot;</span>] = make(map[string]string,2)</span><br><span class="line">studentMap[<span class="string">&quot;stu02&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Mary&quot;</span></span><br><span class="line">studentMap[<span class="string">&quot;stu02&quot;</span>][<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;Female&quot;</span></span><br><span class="line"></span><br><span class="line">studentMap[<span class="string">&quot;stu03&quot;</span>] = make(map[string]string,2)</span><br><span class="line">studentMap[<span class="string">&quot;stu03&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Lawrence&quot;</span></span><br><span class="line">studentMap[<span class="string">&quot;stu03&quot;</span>][<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;Male&quot;</span></span><br></pre></td></tr></table></figure>

<p>map删除操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete(map,<span class="string">&quot;key&quot;</span>)//key不存在不会报错</span><br></pre></td></tr></table></figure>

<p>删除所有的key：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cities = make(map[string]string)//重新分配一个新空间即全部删除key</span><br></pre></td></tr></table></figure>

<p>map查找（判断map中是否存在指定的key）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//方式一</span><br><span class="line">val,findRes = cities[<span class="string">&quot;num1&quot;</span>]// 如果cities存在<span class="string">&quot;num1&quot;</span>，则findRes返回<span class="literal">true</span>，否则返回<span class="literal">false</span></span><br><span class="line">//方式二</span><br><span class="line"><span class="keyword">if</span> cities[<span class="string">&quot;num1&quot;</span>] != nil&#123;</span><br><span class="line">	//存在该用户</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	//不存在该用户</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map遍历（for-range）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var cities map[string]string = map[string]string&#123;</span><br><span class="line">	<span class="string">&quot;num1&quot;</span>:<span class="string">&quot;北京&quot;</span>,</span><br><span class="line">	<span class="string">&quot;num2&quot;</span>:<span class="string">&quot;深圳&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> k,v := range cities&#123;</span><br><span class="line">	fmt.Println(k,v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 嵌套map遍历（复杂的双重for-range）</span><br><span class="line">studentMap := make(map[string]map[string]string)//key类型为string，value类型为map</span><br><span class="line">studentMap[<span class="string">&quot;stu01&quot;</span>] = make(map[string]string,2)</span><br><span class="line">studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">studentMap[<span class="string">&quot;stu01&quot;</span>][<span class="string">&quot;sex&quot;</span>] = <span class="string">&quot;Male&quot;</span></span><br><span class="line"><span class="keyword">for</span> k1,v1 := range studentMap&#123;</span><br><span class="line">	fmt.Println(k1)</span><br><span class="line">	<span class="keyword">for</span> k2,v2 := range v1&#123;</span><br><span class="line">		fmt.Println(k2,<span class="string">&quot;:&quot;</span>,v2,<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取map长度：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(len(studentMap))</span><br></pre></td></tr></table></figure>

<p>map切片：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var monsters []map[string]string // 声明一个切片</span><br><span class="line">monsters = make([]map[string]string,2)//初始化切片</span><br><span class="line"><span class="keyword">if</span> monsters[0] == nil&#123;</span><br><span class="line">	monsters[0] = make(map[string]string,2)</span><br><span class="line">	monsters[0][<span class="string">&quot;name&quot;</span>] = <span class="string">&quot;PersonA&quot;</span></span><br><span class="line">	monsters[0][<span class="string">&quot;age&quot;</span>] = <span class="string">&quot;18&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">// 定义一个monster信息</span><br><span class="line">newMonster := map[string]string&#123;</span><br><span class="line">	<span class="string">&quot;name&quot;</span> : <span class="string">&quot;新英雄&quot;</span>,</span><br><span class="line">	<span class="string">&quot;age&quot;</span> : <span class="string">&quot;22&quot;</span>,</span><br><span class="line">&#125;</span><br><span class="line">monsters = append(monsters,newMonster)</span><br><span class="line">fmt.Println(monsters)</span><br></pre></td></tr></table></figure>

<p>map排序：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">map1 := make(map[int]int,3)</span><br><span class="line">map1[10] = 100</span><br><span class="line">map1[1] = 11</span><br><span class="line">map1[2] = 999</span><br><span class="line">fmt.Println(map1)</span><br><span class="line">var keys []int</span><br><span class="line"><span class="keyword">for</span> k,_ := range map1&#123;</span><br><span class="line">	keys = append(keys,k)</span><br><span class="line">&#125;</span><br><span class="line">// 排序</span><br><span class="line">sort.Ints(keys)</span><br><span class="line">fmt.Println(keys)</span><br><span class="line">// 根据keys遍历切片</span><br><span class="line"><span class="keyword">for</span> _,k := range keys&#123;</span><br><span class="line">	fmt.Print(k,<span class="string">&quot;:&quot;</span>,map1[k],<span class="string">&quot;\t&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map也是引用类型，遵守引用类型的传递机制，在函数接受map后会直接修改原map</p>
<p>复习：切片也是引用类型，切片和map的使用均需要先make分配空间，其中切片的make需要指定长度，map不需要</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func modify(mymap map[int]int)&#123;</span><br><span class="line">	mymap[10] = 100</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	mymap := make(map[int]int)</span><br><span class="line">	mymap[10] = 1</span><br><span class="line">	mymap[20] = 2</span><br><span class="line">	fmt.Println(mymap)</span><br><span class="line">	modify(mymap)</span><br><span class="line">	fmt.Println(mymap)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>map容量达到后会自动扩容，而不会发生panic，即动态增长键值对</p>
<p>map的value也经常用struct类型，更适合于管理复杂的数据</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Stu struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">	Address string</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	students := make(map[string]Stu,10)</span><br><span class="line">	Stu1 := Stu&#123;Name:<span class="string">&quot;Tom&quot;</span>,Age:18,Address:<span class="string">&quot;Beijing&quot;</span>&#125;</span><br><span class="line">	Stu2 := Stu&#123;Name:<span class="string">&quot;Mary&quot;</span>,Age:18,Address:<span class="string">&quot;Hongkong&quot;</span>&#125;</span><br><span class="line">	Stu3 := Stu&#123;Name:<span class="string">&quot;Jack&quot;</span>,Age:18,Address:<span class="string">&quot;Shenzhen&quot;</span>&#125;</span><br><span class="line">	students[<span class="string">&quot;No1&quot;</span>] =Stu1</span><br><span class="line">	students[<span class="string">&quot;No2&quot;</span>] =Stu2</span><br><span class="line">	students[<span class="string">&quot;No3&quot;</span>] =Stu3</span><br><span class="line">	fmt.Println(students)</span><br><span class="line">	<span class="keyword">for</span> k,v := range students&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;学生编号:&quot;</span>,k)</span><br><span class="line">		fmt.Println(<span class="string">&quot;学生姓名:&quot;</span>,v.Name)</span><br><span class="line">		fmt.Println(<span class="string">&quot;学生年龄:&quot;</span>,v.Age)</span><br><span class="line">		fmt.Println(<span class="string">&quot;学生地址:&quot;</span>,v.Address)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="39-结构体"><a href="#39-结构体" class="headerlink" title="39.结构体"></a>39.结构体</h1><p>面向对象编程（OOP, Object Oriented Programming）特性——结构体</p>
<p>（1）Golang和传统的面向对象编程有区别，并不是纯粹的面向对象语言，即通常说Golang支持面向对象编程特性</p>
<p>（2）在Golang中没有类，而结构体与其他编程语言的类有同等地位，基于struct实现OOP，无OOP的继承，方法重载，构造函数，析构函数，隐藏的this指针等</p>
<p>（3）Golang仍然有面向对象编程的继承，封装和多态的特性，只是实现的方式与其他OOP语言不一样，例如继承：Golang没有extend关键字，而是通过<u>匿名字段</u>实现</p>
<p>结构体：声明后，字段/属性拥有默认初始值，注意当字段为：指针/切片/map均为nil，即还没有分配空间</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Stu struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">	Address string</span><br><span class="line">	ptr *int//指针</span><br><span class="line">	slice []int//切片</span><br><span class="line">	mymap map[string]string//map</span><br><span class="line">&#125;</span><br><span class="line">p1 := Stu&#123;<span class="string">&quot;Yoyo&quot;</span>,15,<span class="string">&quot;shenzhen&quot;</span>&#125;</span><br><span class="line">// 使用slice和map均提前make</span><br><span class="line">p1.slice = make([]int,10)</span><br><span class="line">p1.slice[0] = 100</span><br><span class="line"></span><br><span class="line">p1.mymap = make(map[string]string)</span><br><span class="line">p1.mymap[<span class="string">&quot;keya&quot;</span>] = <span class="string">&quot;valuea&quot;</span></span><br><span class="line">fmt.Println(p1)</span><br></pre></td></tr></table></figure>

<p>不同结构体变量的字段是独立的，互不影响，即一个结构体变量字段更改不影响另外一个</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//声明1</span><br><span class="line">var p2 Stu</span><br><span class="line">//声明2</span><br><span class="line">//var p2 Stu = Stu&#123;&#125;</span><br><span class="line">p2.Name = <span class="string">&quot;KK&quot;</span></span><br><span class="line">p2.Age = 23</span><br><span class="line">p3 := p2 // 默认值拷贝</span><br><span class="line">p3.Age = 24</span><br><span class="line">fmt.Println(p2)//&#123;KK 23  &lt;nil&gt; [] map[]&#125;</span><br><span class="line">fmt.Println(p3)//&#123;KK 24  &lt;nil&gt; [] map[]&#125;</span><br></pre></td></tr></table></figure>

<p>创建结构体变量：以下两种方式返回结构体指针</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line">// 声明3</span><br><span class="line">var p3 *Person = new (Person)</span><br><span class="line">(*p3).Name = <span class="string">&quot;Jack~&quot;</span>//注意：<span class="string">&quot;.&quot;</span>的运算符优先级高于<span class="string">&quot;*&quot;</span>，因此必须加上()</span><br><span class="line">(*p3).Age = 28</span><br><span class="line">// 以上可等价于(设计目的：方便使用，在go编译器底层对其转换，默认添加*)</span><br><span class="line">p3.Name = <span class="string">&quot;Pearson&quot;</span></span><br><span class="line">fmt.Println(p3)</span><br><span class="line">// 声明4</span><br><span class="line">var p4 *Person = &amp;Person&#123;&#125;</span><br><span class="line">(*p4).Name = <span class="string">&quot;Alex&quot;</span></span><br><span class="line">//等价于</span><br><span class="line">p4.Name = <span class="string">&quot;Fisher&quot;</span></span><br><span class="line">fmt.Println(p4)</span><br></pre></td></tr></table></figure>

<p>结构体的所有字段在内存中是连续分布的（可熟练通过地址获取内容），但是其指向的地址不一定连续（可能连续）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 打印结构体字段的地址</span><br><span class="line">fmt.Printf(<span class="string">&quot;Name的地址：%p,Age的地址：%p&quot;</span>,&amp;p3.Name,&amp;p3.Age)</span><br></pre></td></tr></table></figure>

<p>结构体在与其他类型转换时需要有相同的字段（名字、个数、类型）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A struct&#123;</span><br><span class="line">	Num int</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> B struct&#123;</span><br><span class="line">	Num int</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var a A</span><br><span class="line">	var b B</span><br><span class="line">	a = A(b)</span><br><span class="line">	fmt.Println(a)//强制转换可通过（A和B结构体的字段名字、个数、类型一致）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体进行type重新定义（重命名），Golang认为该新名为新的数据类型，不可以直接赋值，但是可以互相强制转换</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Student struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Stu Student//重命名</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var stu1 Student</span><br><span class="line">	var stu2 Stu</span><br><span class="line">	//stu2 = stu1//ERROR，不可以直接赋值，数据类型不匹配</span><br><span class="line">	stu2 = Stu(stu1)//需要使用强制转换</span><br><span class="line">	fmt.Println(stu2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct的每个字段上，可以写上一个tag，该tag可以通过<u>反射机制(后续介绍)</u>获取，常见的使用场景是序列化和反序列化</p>
<p>序列化：变量转成字符串（Json）</p>
<p>问题：在结构体中字段名通常首字母为大写，不过在返回给其他程序使用时，例如jquery.php不习惯首字母大写的方式，由于其他包访问结构体字段时如果遇到小写则无法共享，因此必须使用大写</p>
<p>解决：使用tag标签解决（import “encoding/json”）</p>
<p>tag格式：<code>json:&quot;别名&quot;</code></p>
<p><u>json.Marshal函数使用反射(后续介绍)</u></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct&#123;</span><br><span class="line">	Name string `json:<span class="string">&quot;name&quot;</span>`//使用反引号，`json:<span class="string">&quot;别名&quot;</span>`</span><br><span class="line">	Age int `json:<span class="string">&quot;age&quot;</span>`</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	p1 := Person&#123;<span class="string">&quot;TT&quot;</span>,25&#125;//创建一个Person变量</span><br><span class="line">	jsonPerson,error := json.Marshal(p1)//返回2个值([]byte , error)，注意如果结构体字段首字母为小写，该返回为空（即不显示首字母小写的字段信息），由于json在另一个包调用该包</span><br><span class="line">	<span class="keyword">if</span> error == nil&#123;</span><br><span class="line">		fmt.Println(string(jsonPerson))//使用反引号后首字母小写</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结创建结构体变量：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//方式1（可指定字段值名，也可忽略）</span><br><span class="line">var stu1 Student = Student(<span class="string">&quot;Tom&quot;</span>,18)</span><br><span class="line">//方式2</span><br><span class="line">stu2 := Student&#123;<span class="string">&quot;JoJo&quot;</span>,19&#125;</span><br><span class="line">//方式3</span><br><span class="line">var stu3 *Student = &amp;Student&#123;<span class="string">&quot;Smith&quot;</span>,30&#125;</span><br></pre></td></tr></table></figure>

<h1 id="40-方法"><a href="#40-方法" class="headerlink" title="40.方法"></a>40.方法</h1><p>Golang的方法是作用在指定的数据类型，自定义类型都可以有方法，不仅仅struct</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A struct&#123;</span><br><span class="line">	Num int</span><br><span class="line">&#125;</span><br><span class="line">func (a A)<span class="built_in">test</span>(n int)int&#123;//表示A结构体有<span class="built_in">test</span>()方法</span><br><span class="line">	fmt.Println(a.Num)</span><br><span class="line">	fmt.Println(<span class="string">&quot;received n: &quot;</span>,n)</span><br><span class="line">	<span class="built_in">return</span> n+10</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var a A</span><br><span class="line">	res := a.test(11)</span><br><span class="line">	fmt.Println(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">integer</span> int</span><br><span class="line">func (i interger) <span class="function"><span class="title">print</span></span>()&#123;//值传递</span><br><span class="line">	fmt.Println(<span class="string">&quot;i=&quot;</span>,i)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var i <span class="built_in">integer</span> = 10</span><br><span class="line">	i.print()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">integer</span> int</span><br><span class="line">func (i *<span class="built_in">integer</span>) <span class="function"><span class="title">print</span></span>()&#123;//引用传递</span><br><span class="line">	*i = *i + 1</span><br><span class="line">	fmt.Printf(<span class="string">&quot;i=%v\n&quot;</span>,*i)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var i <span class="built_in">integer</span> = 10</span><br><span class="line">	(&amp;i).<span class="built_in">print</span>()</span><br><span class="line">	fmt.Printf(<span class="string">&quot;i=%v&quot;</span>,i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类型实现了String()方法，则fmt.Println默认调用String()进行输出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Student struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line">func (stu *Student)String()string&#123;</span><br><span class="line">	//该出输入参数为指针类型，是为了main()中fmt.Println(stu)正常输出stu，仅(&amp;stu)才使用改写的String()</span><br><span class="line">	str := fmt.Sprintf(<span class="string">&quot;Name=[%v],Age=[%v]&quot;</span>,stu.Name,stu.Age)//底层优化可省略<span class="string">&quot;*&quot;</span></span><br><span class="line">	<span class="built_in">return</span> str</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	stu := Student&#123;<span class="string">&quot;Chen&quot;</span>,25&#125;</span><br><span class="line">	fmt.Println(stu)//&#123;Chen 25&#125;</span><br><span class="line">	// 实现了*Student类型的String方法，则在执行fmt.Println()自动调用</span><br><span class="line">	fmt.Println(&amp;stu)//Name=[Chen],Age=[25]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法和函数的区别 - 1：</p>
<blockquote>
<p>函数调用方式：函数名(实参列表)</p>
<p>方法调用方式：变量.方法名(实参列表)</p>
</blockquote>
<p>方法和函数的区别 - 2：</p>
<blockquote>
<p>普通函数：接受者为值类型时，不能将指针类型的数据直接传递，即形参类型必须与定义的的类型一致</p>
<p>方法：接收者为值类型时，可以直接使用指针类型，但仍然为方法的传递机制（基于方法，默认底层优化的机制）</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(p Person) <span class="function"><span class="title">print</span></span>()  &#123;//值传递（不管是结构体变量还是其地址）</span><br><span class="line">	p.Name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">	//fmt.Println(<span class="string">&quot;print() Name = &quot;</span>,p.Name)</span><br><span class="line">&#125;</span><br><span class="line">func (p *Person) <span class="function"><span class="title">print2</span></span>()&#123;//引用传递（不管是结构体变量还是其地址）</span><br><span class="line">	p.Name = <span class="string">&quot;Jack&quot;</span></span><br><span class="line">	//fmt.Println(<span class="string">&quot;print2() Name = &quot;</span>,p.Name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	p := Person&#123;<span class="string">&quot;ABC&quot;</span>,22&#125;</span><br><span class="line">	p.print()//结构体变量</span><br><span class="line">	(&amp;p).<span class="built_in">print</span>()//结构体变量地址（本质仍然是值传递）</span><br><span class="line">	fmt.Println(<span class="string">&quot;print()-&gt;main() Name=&quot;</span>,p.Name)//<span class="built_in">print</span>()-&gt;main() Name= ABC（没有变化）</span><br><span class="line">	p.print2()//结构体变量</span><br><span class="line">	fmt.Println(<span class="string">&quot;print2()-&gt;main() Name=&quot;</span>,p.Name)//print2()-&gt;main() Name= Jack（变化了）</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="41-工厂模式"><a href="#41-工厂模式" class="headerlink" title="41.工厂模式"></a>41.工厂模式</h1><p>Golang的结构体没有构造函数，通常使用工厂模式来解决问题 </p>
<p>需要：结构体名首字母小写且可以被其他包所调用</p>
<p>不使用工厂模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 文件1 awesomeProject/utils/utils.go</span><br><span class="line">package utils</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Student struct &#123;//必须大写才可以被其他包调用</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文件2 awesomeProject/main/helloworld.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">&quot;awesomeProject/utils&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	stu := utils.Student&#123;<span class="string">&quot;Chen&quot;</span>,25&#125;</span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用工厂模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 文件1 awesomeProject/utils/utils.go</span><br><span class="line">package utils</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> student struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于student结构体首字母小写，因此只能在utils.go中使用，可以通过工厂模式解决</span><br><span class="line"></span><br><span class="line">func NewStudent(n string, a int) *student&#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;student&#123;n,a&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 文件2 awesomeProject/main/helloworld.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">&quot;awesomeProject/utils&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	stu := utils.NewStudent(<span class="string">&quot;Chen&quot;</span>,25)</span><br><span class="line">	fmt.Println(stu)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遇到结构体字段的首字母小写时，可使用Get..()方法解决</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// 文件1 awesomeProject/utils/utils.go</span><br><span class="line">package utils</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> student struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">	age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 由于student结构体首字母小写，因此只能在utils.go中使用，可以通过工厂模式解决</span><br><span class="line"></span><br><span class="line">func NewStudent(n string, a int) *student&#123;</span><br><span class="line">	<span class="built_in">return</span> &amp;student&#123;n,a&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s *student) GetAge() int  &#123;</span><br><span class="line">	<span class="built_in">return</span> s.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 文件2 awesomeProject/main/helloworld.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	<span class="string">&quot;awesomeProject/utils&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	stu := utils.NewStudent(<span class="string">&quot;Chen&quot;</span>,25)</span><br><span class="line">	fmt.Println(stu.GetAge())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="42-继承"><a href="#42-继承" class="headerlink" title="42.继承"></a>42.继承</h1><p>使用嵌套匿名结构体实现继承</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Goods struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Price int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Book struct&#123;</span><br><span class="line">	Goods//嵌套匿名结构体Goods</span><br><span class="line">	Writer string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	book1 := utils.Book&#123;utils.Goods&#123;Name:<span class="string">&quot;书籍1&quot;</span>,Price:18&#125;,<span class="string">&quot;Tomcat&quot;</span>&#125;</span><br><span class="line">	fmt.Println(book1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体可用嵌套匿名结构体所有字段和方法，即首字母大小写的字段、方法均可使用，调用方法时会先寻找本身结构体的方法，若找不到则向上寻找方法</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func (good Goods) <span class="function"><span class="title">Print</span></span>()&#123;</span><br><span class="line">	fmt.Println(good)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (book Book) <span class="function"><span class="title">Print</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">book1.Goods.Name = <span class="string">&quot;bbb&quot;</span> //修改Goods的字段值</span><br><span class="line">book1.Print() //调用Book/Goods的方法，当找不到Book类型的方法则自动向上寻找</span><br></pre></td></tr></table></figure>

<p>如果struct嵌套了一个有名结构体，该模式为组合，如果是组合关系，那么在访问组合的结构体字段/方法时，必须带上结构体名字</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> B struct&#123;</span><br><span class="line">	nickname A //有名结构体，格式：字段名 字段类型</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> C struct&#123;</span><br><span class="line">	*A // 嵌套结构体指针其效率更高，注意声明结构体变量的操作【遇到指针就给地址，也返回地址】</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var b B</span><br><span class="line">	b.nickname.Name = <span class="string">&quot;aaa&quot;</span></span><br><span class="line">	b.nickname.Age = 11</span><br><span class="line">	fmt.Println(b)</span><br><span class="line">	</span><br><span class="line">	c := C&#123;&amp;A&#123;<span class="string">&quot;aaa&quot;</span>,11&#125;&#125; //需要添加&amp;</span><br><span class="line">	fmt.Println(*c.A)//返回地址，使用*取值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结构体还可以定义基本数据类型直接为字段</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Person struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	int//匿名字段：基本数据类型</span><br><span class="line">	n int//有相同类型则需重命名</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	p := Person&#123;<span class="string">&quot;aa&quot;</span>,11&#125;</span><br><span class="line">	fmt.Println(p)//使用方法相同</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="43-接口Interface"><a href="#43-接口Interface" class="headerlink" title="43.接口Interface"></a>43.接口Interface</h1><p>接口（interface）类型可以定义一组方法，<u>不需要实现</u>，interface不能包含任何变量，在某个自定义类型需要使用时才根据具体情况<u>实现所有方法</u></p>
<p>例子1：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 定义2个方法的接口</span><br><span class="line"><span class="built_in">type</span> geometry interface &#123; //声明2个没有实现的方法</span><br><span class="line">    area() float64</span><br><span class="line">    perim() float64</span><br><span class="line">&#125;</span><br><span class="line">// 定义结构体</span><br><span class="line"><span class="built_in">type</span> rect struct &#123;</span><br><span class="line">    width, height float64</span><br><span class="line">&#125;</span><br><span class="line">// 让rect结构体实现geometry接口的定义方法area()</span><br><span class="line">func (r rect) area() float64 &#123;</span><br><span class="line">    <span class="built_in">return</span> r.width * r.height</span><br><span class="line">&#125;</span><br><span class="line">// 让rect结构体实现geometry接口的定义方法perim()</span><br><span class="line">func (r rect) perim() float64 &#123;</span><br><span class="line">    <span class="built_in">return</span> 2*r.width + 2*r.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子2：（接口——“松耦合高类聚”的思想）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Usb interface&#123;</span><br><span class="line">	Start()</span><br><span class="line">	Stop()</span><br><span class="line">&#125;</span><br><span class="line">// 定义Phone结构体</span><br><span class="line"><span class="built_in">type</span> Phone struct&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">// 让Phone结构体实现Usb的接口方法（不需要显式定义，即未知是Usb接口所声明的方法，与java中的implement关键字的继承截然不同）</span><br><span class="line">func (phone Phone)<span class="function"><span class="title">Start</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone is started&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (phone Phone)<span class="function"><span class="title">Stop</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone is stoped&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 定义Camera结构体</span><br><span class="line"><span class="built_in">type</span> Camera struct&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">// 让Camera结构体实现Usb的接口方法</span><br><span class="line">func (camera Camera)<span class="function"><span class="title">Start</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera is started&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (camera Camera)<span class="function"><span class="title">Stop</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera is stoped&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 定义Computer结构体</span><br><span class="line"><span class="built_in">type</span> Computer struct&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">//接收一个Usb接口类型变量，实现了Usb接口，即实现Usb接口所声明的所有方法</span><br><span class="line">func (c Computer) Working(usb Usb)&#123;</span><br><span class="line">	usb.Start()//通过usb接口变量调用start()方法</span><br><span class="line">	usb.Stop()//通过usb接口变量调用stop()方法</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	computer := Computer&#123;&#125;</span><br><span class="line">	phone := Phone&#123;&#125;</span><br><span class="line">	camera := Camera&#123;&#125;</span><br><span class="line">	</span><br><span class="line">	computer.Working(phone)//传入的Phone类型变量，即调用Phone.start()和Phone.stop()</span><br><span class="line">	computer.Working(camera)//调用Camera.start()和Camera.stop()</span><br><span class="line">	// 以上传入Phone和Camera类似于多态，呈现不同的状态</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口相关知识：</p>
<p>（1）接口本身不能创建实例，但是可以指向一个实现了该接口的自定义类型的变量（实例）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A interface&#123;</span><br><span class="line">	Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//定义一个结构体并实现A接口的方法</span><br><span class="line"><span class="built_in">type</span> Stu struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line">func (student Stu)<span class="function"><span class="title">Say</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;student is saying&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var student Stu</span><br><span class="line">	var a A = student//若不实现Say()方法，即Student必须实现A接口声明的方法，则尽可以声明a，但无法实例化a，即无法将一个其他类型赋给接口类型变量a</span><br><span class="line">	a.Say()//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）接口中的所有方法都没有方法体，即没有实现的方法</p>
<p>（3）需要将接口作为形参传入时，即实现该接口，即需要实现该接口所声明的所有方法</p>
<p>（4）一个自定义类型只有实现了某接口，才能将该自定义类型的实例赋给接口类型</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例子如（1）</span><br></pre></td></tr></table></figure>

<p>（5）所有自定义数据类型均可以实现接口</p>
<p>（6）一个自定义类型可以实现多个接口</p>
<p>（7）接口中不允许有变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A interface&#123;</span><br><span class="line">	Name string//×不允许定义</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>（8）一个接口可以继承多个接口，需实现继承的全部接口所声明的方法</p>
<p>（9）接口类型默认是指针（引用类型），没有对其初始化时会输出<nil></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A interface&#123;</span><br><span class="line">	start()</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var a A</span><br><span class="line">	fmt.Println(a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（10）空接口没有任何方法，即所有类型均实现了空接口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> T interface&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var student Stu</span><br><span class="line">	var t interface&#123;&#125; = student //空接口</span><br><span class="line">	var t T = student //空接口	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（11）接口继承多接口时，不允许有重复方法名</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A interface&#123;</span><br><span class="line">	Test1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> B interface&#123;</span><br><span class="line">	Test1()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> C interface&#123;//继承多接口出现了重复方法名</span><br><span class="line">	A</span><br><span class="line">	B</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（12）变量指针类型和变量类型是有区别的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> A interface&#123;</span><br><span class="line">	Say()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Stu struct&#123;</span><br><span class="line">&#125;</span><br><span class="line">func (stu *Stu) <span class="function"><span class="title">Say</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Stu Say()&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var stu Stu = Stu&#123;&#125;</span><br><span class="line">	var a A = stu//编译不通过，由于实现的是指针类型</span><br><span class="line">	var a A = &amp;stu//编译通过</span><br><span class="line">	a.Say()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（13）实现结构体切片的排序：sort.Sort(data Interface)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">import (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;math/rand&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">//1.声明Person结构体</span><br><span class="line"><span class="built_in">type</span> Person struct&#123;</span><br><span class="line">	Name string</span><br><span class="line">	Age int</span><br><span class="line">&#125;</span><br><span class="line">//2.声明一个Person结构体切片类型</span><br><span class="line"><span class="built_in">type</span> PersonSlice []Person</span><br><span class="line"></span><br><span class="line">//3.实现接口方法（实现Sort需要实现Len()int,Less(i,j int)bool,Swap(i,j int)方法）</span><br><span class="line">func (p PersonSlice) Len() int&#123;</span><br><span class="line">	<span class="built_in">return</span> len(p)</span><br><span class="line">&#125;</span><br><span class="line">func (p PersonSlice) Less(i,j int) bool&#123;//决定使用什么标准排序（按照age从小到大排序）</span><br><span class="line">	<span class="built_in">return</span> p[i].Age &lt; p[j].Age</span><br><span class="line">&#125;</span><br><span class="line">func (p PersonSlice) Swap(i,j int) &#123;</span><br><span class="line">	temp := p[i]</span><br><span class="line">	p[i] = p[j]</span><br><span class="line">	p[j] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//4.测试 结构体切片排序</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	// 定义一个数组/切片</span><br><span class="line">	var intSlice = []int&#123;0,-1,10,7,90&#125;</span><br><span class="line">	sort.Ints(intSlice)</span><br><span class="line">	fmt.Println(intSlice)</span><br><span class="line">	// 定义结构体切片</span><br><span class="line">	var ps PersonSlice</span><br><span class="line">	<span class="keyword">for</span> i:=0;i&lt;10;i++&#123;</span><br><span class="line">		p := Person&#123;</span><br><span class="line">			Name:fmt.Sprintf(<span class="string">&quot;人物%d&quot;</span>,rand.Intn(100)),</span><br><span class="line">			Age:rand.Intn(100),</span><br><span class="line">		&#125;</span><br><span class="line">		ps = append(ps,p)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _,v := range ps&#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">	//5.调用sort.Sort</span><br><span class="line">	sort.Sort(ps)</span><br><span class="line">	fmt.Println(<span class="string">&quot;=======Sorted=======&quot;</span>)</span><br><span class="line">	//6.检查结果</span><br><span class="line">	<span class="keyword">for</span> _,v := range ps&#123;</span><br><span class="line">		fmt.Println(v)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继承：解决代码的复用性和可维护性</p>
<p>接口：设计和规范方法，让自定义类型实现方法</p>
<p>多态参数：接口既可以允许A结构体实现方法，也可以允许B结构体实现方法，即接口会依据具体实现方法的类型变量而定</p>
<p>多态数组：接口类型切片变量既可以存放A结构体也可以存放B结构体</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Usb interface &#123;</span><br><span class="line">	start()</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Phone struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Camera struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line">func (p Phone)<span class="function"><span class="title">start</span></span>()&#123;//多态参数 1</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Phone)<span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Camera)<span class="function"><span class="title">start</span></span>()&#123;//多态参数 2</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Camera)<span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var usbs [3]Usb//多态数组</span><br><span class="line">	usbs[0] = Phone&#123;<span class="string">&quot;vivo&quot;</span>&#125;</span><br><span class="line">	usbs[1] = Phone&#123;<span class="string">&quot;oppo&quot;</span>&#125;</span><br><span class="line">	usbs[2] = Camera&#123;<span class="string">&quot;索尼&quot;</span>&#125;</span><br><span class="line">	fmt.Println(usbs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="44-类型断言assert"><a href="#44-类型断言assert" class="headerlink" title="44.类型断言assert"></a>44.类型断言assert</h1><p>类型断言：由于接口是一般类型，不知道具体类型，如果要转成具体类型，需要使用类型断言</p>
<p>例子 1 ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var t float32</span><br><span class="line">var x interface&#123;&#125;</span><br><span class="line">x = t</span><br><span class="line">y := x</span><br></pre></td></tr></table></figure>



<p>例子 2 ：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> Point struct&#123;</span><br><span class="line">	x,y int</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var a interface&#123;&#125;</span><br><span class="line">	var point Point = Point&#123;1,2&#125;</span><br><span class="line">	a = point // 空接口可接收任何一个变量</span><br><span class="line">	var b Point</span><br><span class="line">	//b = a//ERROR，不允许将空接口（类型不明确）赋给Point类型</span><br><span class="line">	b = a.(Point) //类型断言，即尝试将a变量转换为Point类型变量，成功即通过，不成功即报错</span><br><span class="line">	fmt.Println(b) //&#123;1 2&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>例子 3：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import <span class="string">&quot;fmt&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">type</span> Usb interface &#123;</span><br><span class="line">	start()</span><br><span class="line">	stop()</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Phone struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Camera struct &#123;</span><br><span class="line">	Name string</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">type</span> Computer struct&#123;//不同之处</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func (c Computer)Working(usb Usb)&#123;//不同之处</span><br><span class="line">	usb.start()</span><br><span class="line">	//如果为Phone类型（类型断言）则调用Call()方法</span><br><span class="line">	<span class="keyword">if</span> phone,ok := usb.(Phone);ok&#123;</span><br><span class="line">		phone.Call()</span><br><span class="line">	&#125;</span><br><span class="line">	usb.stop()</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Phone)<span class="function"><span class="title">start</span></span>()&#123;//多态参数 1</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Phone)<span class="function"><span class="title">Call</span></span>()&#123;//多态参数 1</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone is calling&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Phone)<span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;phone stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Camera)<span class="function"><span class="title">start</span></span>()&#123;//多态参数 2</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera start&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">func (p Camera)<span class="function"><span class="title">stop</span></span>()&#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;camera stop&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	var usbs [3]Usb//多态数组</span><br><span class="line">	usbs[0] = Phone&#123;<span class="string">&quot;vivo&quot;</span>&#125;</span><br><span class="line">	usbs[1] = Phone&#123;<span class="string">&quot;oppo&quot;</span>&#125;</span><br><span class="line">	usbs[2] = Camera&#123;<span class="string">&quot;索尼&quot;</span>&#125;</span><br><span class="line">	//fmt.Println(usbs)</span><br><span class="line">	var computer Computer</span><br><span class="line">	<span class="keyword">for</span> _,v := range(usbs)&#123;</span><br><span class="line">		computer.Working(v)//基于v的类型调用usb.start()和usb.stop()因此，前2组为手机，第3组为相机</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子 4：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">func Typejudge(items ...interface&#123;&#125;)&#123;</span><br><span class="line">	<span class="keyword">for</span> i,x := range items&#123;</span><br><span class="line">		switch x.(<span class="built_in">type</span>) &#123;</span><br><span class="line">			<span class="keyword">case</span> bool:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为布尔类型\n&quot;</span>,i)</span><br><span class="line">			<span class="keyword">case</span> int,int32,int64:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为整数类型\n&quot;</span>,i)</span><br><span class="line">			<span class="keyword">case</span> float32,float64:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为浮点数类型\n&quot;</span>,i)</span><br><span class="line">			<span class="keyword">case</span> string:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为字符串类型\n&quot;</span>,i)</span><br><span class="line">			<span class="keyword">case</span> *Student:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为*Student类型\n&quot;</span>,i)</span><br><span class="line">			<span class="keyword">case</span> Student:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为Student类型\n&quot;</span>,i)</span><br><span class="line">			default:</span><br><span class="line">				fmt.Printf(<span class="string">&quot;第%v个参数为其他类型\n&quot;</span>,i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">func <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">	a := 1</span><br><span class="line">	b := <span class="string">&quot;ss&quot;</span></span><br><span class="line">	c := 5.5</span><br><span class="line">	d := Student&#123;<span class="string">&quot;Jomin&quot;</span>&#125;</span><br><span class="line">	Typejudge(a,b,c,d,&amp;d)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>TODO  尚硅谷韩顺平Go语言核心编程 P229 226家庭收支记账 / P391 387结束语</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2020/09/17/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Go/" data-id="ckmzn8pxn001oj2td8hkh4qg6" data-title="日常笔记——Go" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/09/17/%E6%97%A5%E5%B8%B8%E9%97%AE%E9%A2%98%E2%80%94%E2%80%94Jupyter%E6%B7%BB%E5%8A%A0%E4%BB%A3%E7%A0%81%E8%A1%A5%E5%85%A8%E5%8A%9F%E8%83%BD/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Neuer</strong>
      <div class="article-nav-title">
        
          日常问题——Jupyter添加代码补全功能
        
      </div>
    </a>
  
  
    <a href="/2020/09/17/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94git/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">日常笔记——git</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Django/">Django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/idea/">idea</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/06/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Sentry/">日常笔记——Sentry</a>
          </li>
        
          <li>
            <a href="/2021/04/02/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94urljoin/">日常笔记——urljoin</a>
          </li>
        
          <li>
            <a href="/2021/04/01/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94k8s/">日常笔记——k8s</a>
          </li>
        
          <li>
            <a href="/2021/04/01/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/01/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Python/">日常笔记——Python</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Jimmy Guo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>