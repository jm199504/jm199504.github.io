<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>EKL | Jimmy&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="概述：EKL">
<meta property="og:type" content="article">
<meta property="og:title" content="EKL">
<meta property="og:url" content="http://example.com/2021/04/07/EKL/index.html">
<meta property="og:site_name" content="Jimmy&#39;s blog">
<meta property="og:description" content="概述：EKL">
<meta property="og:locale">
<meta property="og:image" content="https://www.tizi365.com/wp-content/uploads/2020/06/basic_logstash_pipeline-1024x228.png">
<meta property="og:image" content="https://www.tizi365.com/wp-content/uploads/2020/06/filebeat.png">
<meta property="article:published_time" content="2021-04-07T11:00:34.145Z">
<meta property="article:modified_time" content="2021-04-08T15:26:23.624Z">
<meta property="article:author" content="Jimmy Guo">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://www.tizi365.com/wp-content/uploads/2020/06/basic_logstash_pipeline-1024x228.png">
  
    <link rel="alternate" href="/atom.xml" title="Jimmy's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Jimmy&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Suche"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-EKL" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/EKL/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T11:00:34.145Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Notes/">Notes</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      EKL
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>概述：EKL</p>
<span id="more"></span>

<p>[TOC]</p>
<h2 id="一、基础知识"><a href="#一、基础知识" class="headerlink" title="一、基础知识"></a>一、基础知识</h2><p>Kibana 是一款开源的数据分析和可视化平台，是 Elasticsearch 的web管理后台。</p>
<p>Kibana Query Language （KQL）查询语法是Kibana为了简化ES查询设计的一套简单查询语法，Kibana支持索引字段和语法补全。</p>
<p>本文提及的工具均依赖JDK版本：JDK 1.8以上，没有安装jdk可以安装jdk，配置好Java环境变量。</p>
<p>ELK = Elasticsearch + Logstash + Kibana</p>
<ul>
<li>Elasticsearch - 前面简介提到过，解决海量数据搜索问题。</li>
<li>Logstash - 解决数据同步问题，因为我们数据一般存储在Mysql之类的数据库中，需要将数据导入到ES中，Logstash就支持数据同步、数据过滤、转换功能。</li>
<li>Kibana - Elasticsearch数据可视化支持，例如：通过各种图表展示ES的查询结果，也可以在Kibana通过ES查询语句分析数据，起到类似ES Web后台的作用。</li>
</ul>
<h2 id="二、Elasticsearch-（🌟-）"><a href="#二、Elasticsearch-（🌟-）" class="headerlink" title="二、Elasticsearch （🌟 ）"></a>二、Elasticsearch （🌟 ）</h2><p>Elasticsearch 是一个分布式、RESTful 风格的搜索和数据分析引擎, 国内简称ES，Elasticsearch是用java开发的，底层基于Lucene, Lucene是一种全文检索的搜索库，直接使用Lucene还是比较麻烦的，Elasticsearch在Lucene的基础上开发了一个强大的搜索引擎。</p>
<h2 id="2-1-Install"><a href="#2-1-Install" class="headerlink" title="2.1 Install"></a>2.1 Install</h2><p>Elasticsearch - Download</p>
<ul>
<li>Windows <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.1-windows-x86_64.zip">elasticsearch-7.5.1-windows-x86_64.zip</a></li>
<li>Linux <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.1-linux-x86_64.tar.gz">elasticsearch-7.5.1-linux-x86_64.tar.gz</a></li>
<li>macOS <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-7.5.1-darwin-x86_64.tar.gz">elasticsearch-7.5.1-darwin-x86_64.tar.gz</a></li>
</ul>
<p>解压缩 &amp; 启动（macOS）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 解压</span><br><span class="line">tar -zxvf elasticsearch-7.5.1-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line"># 切换到安装目录</span><br><span class="line">cd elasticsearch-7.5.1</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">.&#x2F;bin&#x2F;elasticsearch</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:9200&#x2F;</span><br></pre></td></tr></table></figure>

<h2 id="2-2-debug-Elasticsearch-by-Restful-api"><a href="#2-2-debug-Elasticsearch-by-Restful-api" class="headerlink" title="2.2 debug Elasticsearch by Restful api"></a>2.2 debug Elasticsearch by Restful api</h2><p>elasticsearch是以http Restful api的形式提供接口，我们要操作ES，只要调用http接口就行，ES的默认端口是9200</p>
<h3 id="2-2-1-curl-demo"><a href="#2-2-1-curl-demo" class="headerlink" title="2.2.1 curl demo"></a>2.2.1 curl demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -X GET &quot;localhost:9200&#x2F;_cat&#x2F;health?v&amp;pretty&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-postman-demo"><a href="#2-2-2-postman-demo" class="headerlink" title="2.2.2 postman demo"></a>2.2.2 postman demo</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET http:&#x2F;&#x2F;localhost:9200&#x2F;_search</span><br></pre></td></tr></table></figure>

<h2 id="2-3-存储结构"><a href="#2-3-存储结构" class="headerlink" title="2.3 存储结构"></a>2.3 存储结构</h2><p>Elasticsearch是NOSQL类型的数据库</p>
<h3 id="2-3-1-index-索引"><a href="#2-3-1-index-索引" class="headerlink" title="2.3.1 index(索引)"></a>2.3.1 index(索引)</h3><p>在Elasticsearch中索引（index）类似mysql的表，代表文档数据的集合，文档指的是ES中存储的一条数据。</p>
<h3 id="2-3-2-type-文档类型"><a href="#2-3-2-type-文档类型" class="headerlink" title="2.3.2 type(文档类型)"></a>2.3.2 type(文档类型)</h3><p>在新版的Elasticsearch中，已经不使用文档类型了，在Elasticsearch老的版本中文档类型，代表一类文档的集合，index(索引)类似mysql的数据库、文档类型类似Mysql的表。</p>
<p>index（索引）就类似mysql的表的概念，ES没有数据库的概念了。</p>
<p>提示：在Elasticsearch7.0以后的版本，已经废弃文档类型了，可以直接将index（索引）类比Mysql的表。</p>
<h3 id="2-3-3-Document-文档"><a href="#2-3-3-Document-文档" class="headerlink" title="2.3.3 Document(文档)"></a>2.3.3 Document(文档)</h3><p>Elasticsearch是面向文档的数据库，文档是最基本的存储单元，文档类似mysql表中的一行数据。</p>
<p>简单的说在ES中，文档指的就是一条JSON数据。</p>
<p>Elasticsearch中文档使用<strong>json格式</strong>存储，因此存储上比Mysql要灵活的多，Elasticsearch支持任意格式的json数据。</p>
<p>例如：一个订单数据，我们可以将复杂的Json结构保存到Elasticsearch中， mysql的就无法这样存储数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;id&quot;: 12,</span><br><span class="line">	&quot;status&quot;: 1,</span><br><span class="line">	&quot;total_price&quot;: 100,</span><br><span class="line">	&quot;create_time&quot;: &quot;2019-12-12 12:20:22&quot;,</span><br><span class="line">	&quot;user&quot; : &#123; &#x2F;&#x2F; 嵌套json对象</span><br><span class="line">		&quot;id&quot; : 11,</span><br><span class="line">		&quot;username&quot;: &quot;junmingguo&quot;,</span><br><span class="line">		&quot;phone&quot;: &quot;13500001111&quot;,</span><br><span class="line">		&quot;address&quot; : &quot;上海长宁区001号&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文档中的任何json字段都可以作为查询条件。</strong></p>
<p><strong>文档的json格式没有严格限制，可以随意增加、减少字段，甚至每一个文档的格式都不一样也可以。</strong></p>
<p>例子：在同一个索引存中，存储格式完全不一样的文档数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;id&quot;:1, &quot;username&quot;:&quot;junmingguo&quot;&#125;</span><br><span class="line">&#123;&quot;id&quot;:1, &quot;title&quot;:&quot;好看的包包&quot;, &quot;price&quot;: 30&#125;</span><br><span class="line">&#123;&quot;domain&quot;:&quot;abc.com&quot;, &quot;https&quot;: true&#125;</span><br></pre></td></tr></table></figure>

<p>提示：虽然文档的格式没有限制，可以随便存储任意格式数据，但是，实际业务中不会这么干，通常一个索引只会存储格式相同的数据，例如：订单索引，只会保存订单数据，不会保存商品数据，否则你会被自己搞死，自己都不知道里面存的是什么数据。</p>
<h3 id="2-3-4-Field-文档字段"><a href="#2-3-4-Field-文档字段" class="headerlink" title="2.3.4 Field(文档字段)"></a>2.3.4 Field(文档字段)</h3><p>文档由多个json字段（Field）组成， 这里的字段类似mysql中表的字段。</p>
<p>当然Elasticsearch中字段也有类型的，下面是常用的字段类型:</p>
<ul>
<li>数值类型（包括: long、integer、short、byte、double、float）</li>
<li>text - 支持全文搜索</li>
<li>keyword - 不支持全文搜索，例如：email、电话这些数据，作为一个整体进行匹配就可以，不需要分词处理。</li>
<li>date - 日期类型</li>
<li>boolean</li>
</ul>
<p>后面的章节会专门介绍字段类型，Elasticsearch支持的字段类型远比这里介绍的多。</p>
<p>提示：Elasticsearch支持动态映射，我们可以不必预先定义文档的json结构和对应的字段类型，Elasticsearch会自动推断字段的类型。</p>
<h3 id="2-3-5-mapping-映射"><a href="#2-3-5-mapping-映射" class="headerlink" title="2.3.5 mapping (映射)"></a>2.3.5 mapping (映射)</h3><p>Elasticsearch的mapping (映射)类似mysql中的表结构定义，每个索引都有一个映射规则，我们可以通过定义索引的映射规则，提前定义好文档的json结构和字段类型，如果没有定义索引的映射规则，Elasticsearch会在写入数据的时候，根据我们写入的数据字段推测出对应的字段类型，相当于自动定义索引的映射规则。</p>
<p>提示：虽然Elasticsearch的自动映射功能很方便，但是实际业务中，对于关键的字段类型，通常预先定义好，避免Elasticsearch自动生成的字段类型不是你想要的类型，例如: ES默认将字符串类型数据自动定义为text类型，但是关于手机号，我们希望是keyword类型，这个时候就需要通过mapping预先定义号对应的字段类型了。</p>
<h3 id="2-3-6-类比mysql存储结构"><a href="#2-3-6-类比mysql存储结构" class="headerlink" title="2.3.6 类比mysql存储结构"></a>2.3.6 类比mysql存储结构</h3><table>
<thead>
<tr>
<th>Elasticsearch存储结构</th>
<th>MYSQL存储结构</th>
</tr>
</thead>
<tbody><tr>
<td>index(索引)</td>
<td>表</td>
</tr>
<tr>
<td>文档</td>
<td>行，一行数据</td>
</tr>
<tr>
<td>Field(字段）</td>
<td>表字段</td>
</tr>
<tr>
<td>mapping (映射)</td>
<td>表结构定义</td>
</tr>
</tbody></table>
<h2 id="2-4-CRUD-操作"><a href="#2-4-CRUD-操作" class="headerlink" title="2.4 CRUD 操作"></a>2.4 CRUD 操作</h2><h3 id="2-4-1-文档"><a href="#2-4-1-文档" class="headerlink" title="2.4.1 文档"></a>2.4.1 文档</h3><p>在Elasticsearch中，文档其实就是一条JSON数据。</p>
<p>JSON数据格式可以非常复杂，也可以很简单。</p>
<p>JSON文档的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;id&quot;: 12,</span><br><span class="line">	&quot;status&quot;: 1,</span><br><span class="line">	&quot;total_price&quot;: 100,</span><br><span class="line">	&quot;create_time&quot;: &quot;2019-12-12 12:20:22&quot;,</span><br><span class="line">	&quot;user&quot; : &#123; &#x2F;&#x2F; 嵌套json对象</span><br><span class="line">		&quot;id&quot; : 11,</span><br><span class="line">		&quot;username&quot;: &quot;jimmy&quot;,</span><br><span class="line">		&quot;phone&quot;: &quot;13500001111&quot;,</span><br><span class="line">		&quot;address&quot; : &quot;上海长宁区001号&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES中索引类似MYSQL表的概念，索引包含多个文档数据。</p>
<p>提示： ES 索引不要求，同一个索引中的所有JSON文档的格式都一样，甚至可以在同一个索引中保存完全不一样格式的JSON数据，当然不推荐这么做，建议同一个索引仅保存格式相同的数据，例如：订单索引，仅保存订单数据，不要保存其他业务数据。</p>
<h3 id="2-4-2-文档元数据"><a href="#2-4-2-文档元数据" class="headerlink" title="2.4.2 文档元数据"></a>2.4.2 文档元数据</h3><p>文档元数据，指的是插入JSON文档的时候，Elasticsearch为这条数据，<strong>自动生成的系统字段</strong>。</p>
<p><strong>元数据的字段名都是以下划线开头的。</strong></p>
<p>常见的元数据如下：</p>
<ul>
<li>_index - 代表当前JSON文档所属的文档名字</li>
<li>_type - 代表当前JSON文档所属的类型，虽然新版ES废弃了type的用法，但是元数据还是可以看到。</li>
<li>_id - 文档唯一Id, 如果我们没有为文档指定id，系统会自动生成</li>
<li>_source - 代表我们插入进去的JSON数据</li>
<li>_version - 文档的版本号，每修改一次文档数据，字段就会加1， 这个字段新版的ES已经不使用了</li>
<li>_seq_no - 文档的版本号, 替代老的_version字段</li>
<li>_primary_term - 文档所在主分区，这个可以跟_seq_no字段搭配实现乐观锁。</li>
</ul>
<p>下面是从ES查询出来的一条文档的例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;order&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1, &#x2F;&#x2F; 老ES版本的文档版本号，最新版本已经不使用了</span><br><span class="line">  &quot;_seq_no&quot; : 0, &#x2F;&#x2F; 新ES版本的文档版本号</span><br><span class="line">  &quot;_primary_term&quot; : 1, &#x2F;&#x2F; 主分区id</span><br><span class="line">  &quot;_source&quot; : &#123; &#x2F;&#x2F; _source字段保存的就是我们插入到ES中的JSON数据</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;status&quot; : 1,</span><br><span class="line">    &quot;total_price&quot; : 100,</span><br><span class="line">    &quot;create_time&quot; : &quot;2019-12-12 12:20:22&quot;,</span><br><span class="line">    &quot;user&quot; : &#123;</span><br><span class="line">      &quot;id&quot; : 11,</span><br><span class="line">      &quot;username&quot; : &quot;junmingguo&quot;,</span><br><span class="line">      &quot;phone&quot; : &quot;13500001111&quot;,</span><br><span class="line">      &quot;address&quot; : &quot;上海长宁区001号&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-3-插入文档"><a href="#2-4-3-插入文档" class="headerlink" title="2.4.3 插入文档"></a>2.4.3 插入文档</h3><p>在Elasticsearch插入一个JSON文档，又叫<strong>索引文档</strong>， 注意这里的索引跟前面提到的<strong>文档所属的索引名</strong>，不是一回事，很晕吧，其实主要翻译问题，我们将数据插入到ES的过程，其实就是创建索引的过程，所以插入文档，也叫做索引文档，这里索引是动词， 而文档属于哪个索引（index），这里的索引代表一个分类，有数据库的概念，是个名词。</p>
<p>索引文档 = ES插入数据</p>
<p>插入文档的语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;&#123;index&#125;&#x2F;&#123;type&#125;&#x2F;&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;value&quot;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PUT代表发送一个http put请求， 后面的URL参数说明：</p>
<ul>
<li>{index} - 索引名</li>
<li>{type} - 文档类型名 - 新版的Elasticsearch为了兼容老版本，只允许指定一个类型，随便设置一个类型名就行。</li>
<li>{id} - 文档的唯一id， 可以不指定, 如果不指定id, 需要<strong>使用POST发送请求</strong></li>
</ul>
<p>提示：通过curl命令，或者postman测试的话，要加上ES接口地址即可，ES默认地址是<a target="_blank" rel="noopener" href="http://localhost:9200/%E3%80%82">http://localhost:9200/。</a></p>
<p>例子:插入一条JSON数据，到order索引中，文档类型是_doc， 文档id是1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;order&#x2F;_doc&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">	&quot;id&quot;: 1,</span><br><span class="line">	&quot;status&quot;: 1,</span><br><span class="line">	&quot;total_price&quot;: 100,</span><br><span class="line">	&quot;create_time&quot;: &quot;2019-12-12 12:20:22&quot;,</span><br><span class="line">	&quot;user&quot; : &#123; </span><br><span class="line">		&quot;id&quot; : 11,</span><br><span class="line">		&quot;username&quot;: &quot;tizi365&quot;,</span><br><span class="line">		&quot;phone&quot;: &quot;13500001111&quot;,</span><br><span class="line">		&quot;address&quot; : &quot;上海长宁区001号&quot;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：将例子代码，直接贴到Kibana的console中，就可以执行, 在console页面右侧可以直接看到执行结果。</p>
<p>提示：ES支持动态映射，可以根据我们插入的JSON数据，自动推测出JSON字段的类型，所以我们不需要在ES中提前定义JSON的格式。</p>
<h2 id="2-5-eg-查询文档"><a href="#2-5-eg-查询文档" class="headerlink" title="2.5 eg. 查询文档"></a>2.5 eg. 查询文档</h2><p>根据文档ID查询文档。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;index&#125;&#x2F;&#123;type&#125;&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order&#x2F;_doc&#x2F;1</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;order&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;1&quot;,</span><br><span class="line">  &quot;_version&quot; : 1,</span><br><span class="line">  &quot;_seq_no&quot; : 0,</span><br><span class="line">  &quot;_primary_term&quot; : 1,</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;status&quot; : 1,</span><br><span class="line">    &quot;total_price&quot; : 100,</span><br><span class="line">    &quot;create_time&quot; : &quot;2019-12-12 12:20:22&quot;,</span><br><span class="line">    &quot;user&quot; : &#123;</span><br><span class="line">      &quot;id&quot; : 11,</span><br><span class="line">      &quot;username&quot; : &quot;junmingguo&quot;,</span><br><span class="line">      &quot;phone&quot; : &quot;13500001111&quot;,</span><br><span class="line">      &quot;address&quot; : &quot;上海长宁区001号&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-6-eg-更新文档"><a href="#2-6-eg-更新文档" class="headerlink" title="2.6 eg. 更新文档"></a>2.6 eg. 更新文档</h2><p>（1）更新整个文档</p>
<p>更新整个文档语法跟前面介绍的插入文档的语法一模一样，只要ID相同就会直接覆盖之前的文档。</p>
<p>（2）文档局部更新</p>
<p>如果我们只想更新json文档的某些字段，可以使用局部更新语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;&#123;index&#125;&#x2F;_update&#x2F;&#123;id&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123; &#x2F;&#x2F; 在doc字段中指定需要更新的字段</span><br><span class="line">    &#x2F;&#x2F; 需要更新的字段列表</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子:更新order索引中，文档id等于1的json文档，更新status和total_price两个字段</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;order&#x2F;_update&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">    &quot;status&quot;:3,</span><br><span class="line">    &quot;total_price&quot;:200</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：虽然说elasticsearch支持通过Api更新文档，但是ES底层文档是不可变的，每次修改文档，本质上是创建一个新的文档，然后把老的文档标记成删除。</p>
<h2 id="2-7-eg-删除文档"><a href="#2-7-eg-删除文档" class="headerlink" title="2.7 eg. 删除文档"></a>2.7 eg. 删除文档</h2><p>删除语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;&#123;index&#125;&#x2F;&#123;type&#125;&#x2F;&#123;id&#125;</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DELETE &#x2F;order&#x2F;_doc&#x2F;1</span><br></pre></td></tr></table></figure>

<p>说明：ES最强大的特性是搜索，本节没有介绍ES的文档搜索语法，后面的章节会单独介绍。</p>
<h2 id="2-8-基于乐观锁的并发控制"><a href="#2-8-基于乐观锁的并发控制" class="headerlink" title="2.8 基于乐观锁的并发控制"></a>2.8 基于乐观锁的并发控制</h2><p>Mysql 通过加锁确保数据原子性</p>
<p>Elasticsearch通过乐观锁确保文档的原子性</p>
<p>Elasticsearch的乐观锁是基于版本号实现的，CRUD的元数据中_seq_no、version，都代表当前文档的版本号，每次更新、删除文档的时候，版本号都会+1，ES就是根据版本号实现乐观锁。</p>
<p>提示：本教程使用的Elasticsearch7.5.x版本，已经不再使用_version字段作为乐观锁判断的依据，主要使用_seq_no作为版本号，结合_primary_term字段实现乐观锁控制。</p>
<p>首先插入一个文档</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;order&#x2F;_doc&#x2F;2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;status&quot;: 1,</span><br><span class="line">  &quot;total_price&quot;: 100,</span><br><span class="line">  &quot;create_time&quot;: &quot;2019-12-12 12:20:22&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们查询下插入的文档，观察下版本号是多少？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order&#x2F;_doc&#x2F;2</span><br></pre></td></tr></table></figure>

<p>返回</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;_index&quot; : &quot;order&quot;,</span><br><span class="line">  &quot;_type&quot; : &quot;_doc&quot;,</span><br><span class="line">  &quot;_id&quot; : &quot;2&quot;,</span><br><span class="line">  &quot;_version&quot; : 1, </span><br><span class="line">  &quot;_seq_no&quot; : 6, &#x2F;&#x2F; 版本号是6</span><br><span class="line">  &quot;_primary_term&quot; : 1, &#x2F;&#x2F; 所在主分区是1</span><br><span class="line">  &quot;found&quot; : true,</span><br><span class="line">  &quot;_source&quot; : &#123;</span><br><span class="line">    &quot;id&quot; : 1,</span><br><span class="line">    &quot;status&quot; : 1,</span><br><span class="line">    &quot;total_price&quot; : 100,</span><br><span class="line">    &quot;create_time&quot; : &quot;2019-12-12 12:20:22&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们现在以指定的版本号更新数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;order&#x2F;_doc&#x2F;2?if_seq_no&#x3D;6&amp;if_primary_term&#x3D;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: 1,</span><br><span class="line">  &quot;status&quot;: 2,</span><br><span class="line">  &quot;total_price&quot;: 300,</span><br><span class="line">  &quot;create_time&quot;: &quot;2019-12-12 12:20:22&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：注意观察url，多了两个参数，if_seq_no参数，指定了当前文档的版本号是6，if_primary_term参数指定文档所在的主分区，如果ES发现文档当前的版本号跟我们指定的版本号相等，就会更新文档，否则直接忽略（报错）。</p>
<p>重复执行上面的语句，ES就会输出下面的错误提示：版本冲突 （version conflict）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;error&quot;: &#123;</span><br><span class="line">    &quot;root_cause&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">        &quot;reason&quot;: &quot;[2]: version conflict, required seqNo [6], primary term [1]. current document has seqNo [7] and primary term [1]&quot;,</span><br><span class="line">        &quot;index_uuid&quot;: &quot;CRQJQH4uTA2ffetowYCMNA&quot;,</span><br><span class="line">        &quot;shard&quot;: &quot;0&quot;,</span><br><span class="line">        &quot;index&quot;: &quot;order&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;type&quot;: &quot;version_conflict_engine_exception&quot;,</span><br><span class="line">    &quot;reason&quot;: &quot;[2]: version conflict, required seqNo [6], primary term [1]. current document has seqNo [7] and primary term [1]&quot;,</span><br><span class="line">    &quot;index_uuid&quot;: &quot;CRQJQH4uTA2ffetowYCMNA&quot;,</span><br><span class="line">    &quot;shard&quot;: &quot;0&quot;,</span><br><span class="line">    &quot;index&quot;: &quot;order&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;status&quot;: 409</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以通过版本号实现乐观锁，控制出现并发修改文档的时候，确保数据不会出问题。</p>
<h2 id="2-9-数据类型和映射"><a href="#2-9-数据类型和映射" class="headerlink" title="2.9 数据类型和映射"></a>2.9 数据类型和映射</h2><h3 id="2-9-1-ES数据基础类型"><a href="#2-9-1-ES数据基础类型" class="headerlink" title="2.9.1 ES数据基础类型"></a>2.9.1 ES数据基础类型</h3><p>下面是ES支持的数据类型：</p>
<ul>
<li>字符串<ul>
<li>主要包括: text和keyword两种类型，keyword代表精确值不会参与分词，text类型的字符串会参与分词处理。</li>
</ul>
</li>
<li>数值<ul>
<li>包括: long, integer, short, byte, double, float</li>
</ul>
</li>
<li>布尔值<ul>
<li>boolean</li>
</ul>
</li>
<li>时间<ul>
<li>date</li>
</ul>
</li>
<li>数组<ul>
<li>数组类型不需要专门定义，只要插入的字段值是json数组就行。</li>
</ul>
</li>
<li>GEO类型<ul>
<li>主要涉及地理信息检索、多边形区域的表达，后面GEO相关的章节单独讲解</li>
</ul>
</li>
</ul>
<p>提示：text类型，支持全文搜索，因为text涉及分词，所以可以配置使用什么分词器，尤其涉及中文分词，这些涉及全文搜索的内容，请参考后面的全文搜索章节。</p>
<h3 id="2-9-2-精确值-amp-全文类型"><a href="#2-9-2-精确值-amp-全文类型" class="headerlink" title="2.9.2 精确值 &amp; 全文类型"></a>2.9.2 精确值 &amp; 全文类型</h3><p>精确值通常指的就是数值类型、时间、布尔值、字符串的keyword类型，这些不可分割的数据类型，精确值搜索效率比较高，精确值匹配类似MYSQL中根据字段搜索，例如：拿一个手机号去搜索数据，对于每一个文档的手机号字段，要么相等，要么不等，不会做别的计算。</p>
<p>全文类型，指的就是text类型，会涉及分词处理，存储到ES中的数据不是原始数据，是一个个关键词。</p>
<p>例如：我们有一个title字段，数据类型是text, 我们插入”上海复旦大学”这个字符串，经过分词处理，可能变成：”上海”、”复旦大学”、”大学” 这些关键词，然后根据这些关键词建倒排索引。</p>
<p>提示：实际项目中，如果不需要模糊搜索的字符类型，可以选择keyword类型，例如：手机号、email、微信的openid等等，如果选text类型，可能会出现搜出一大堆相似的数据，而且不是精确的数据。</p>
<p>全文搜索后面的章节单独介绍。</p>
<h3 id="2-9-3-自动映射-dynamic-mapping"><a href="#2-9-3-自动映射-dynamic-mapping" class="headerlink" title="2.9.3 自动映射 (dynamic mapping)"></a>2.9.3 自动映射 (dynamic mapping)</h3><p>前面的章节我们没有预先定义文档的映射（数据类型），也可以插入数据，因为ES默认会自动检测我们插入的数据的类型，相当于自动定义文档类型(mapping)。</p>
<p>自动映射的缺点就是会出现ES映射的数据类型，不是我们想要的类型，例如：手机号，我们希望是一个精确值，使用keyword类型，ES映射成为了text类型，这就不符合业务预期了。</p>
<p>提示：实际项目中，我们通常会预先定义好ES的映射规则，也就是类似MYSQL一样，提前定义好表结构。</p>
<h3 id="2-9-4-自定义文档的数据类型"><a href="#2-9-4-自定义文档的数据类型" class="headerlink" title="2.9.4 自定义文档的数据类型"></a>2.9.4 自定义文档的数据类型</h3><p><strong>语法：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;&#123;索引名字&#125;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123; &#x2F;&#x2F; 表示定义映射规则</span><br><span class="line">    &quot;properties&quot;: &#123; &#x2F;&#x2F; 定义属性，也就是字段类型</span><br><span class="line">      &quot;字段名1&quot;:    &#123; &quot;type&quot;: &quot;字段类型&quot; &#125;,  </span><br><span class="line">      &quot;字段名2&quot;:    &#123; &quot;type&quot;: &quot;字段类型&quot; &#125;</span><br><span class="line">      ...(提示：最后一行末尾不要加逗号)...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：创建一个订单索引，索引名字order</p>
<p>订单索引结构如下表：</p>
<table>
<thead>
<tr>
<th>字段名</th>
<th>ES类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>id</td>
<td>integer</td>
<td>订单id，整数</td>
</tr>
<tr>
<td>shop_id</td>
<td>integer</td>
<td>店铺Id, 整数</td>
</tr>
<tr>
<td>user_id</td>
<td>integer</td>
<td>用户id, 整数</td>
</tr>
<tr>
<td>order_no</td>
<td>keyword</td>
<td>订单编号，字符串类型，精确值</td>
</tr>
<tr>
<td>create_at</td>
<td>date</td>
<td>订单创建时间，日期类型</td>
</tr>
<tr>
<td>phone</td>
<td>keyword</td>
<td>电话号码，字符串类型，精确值</td>
</tr>
<tr>
<td>address</td>
<td>text</td>
<td>用户地址，字符串类型，需要模糊搜索</td>
</tr>
</tbody></table>
<p>创建ES索引：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;order</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;id&quot;:    	&#123; &quot;type&quot;: &quot;integer&quot; &#125;,  </span><br><span class="line">      &quot;shop_id&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,  </span><br><span class="line">      &quot;user_id&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,</span><br><span class="line">      &quot;order_no&quot;:  &#123; &quot;type&quot;: &quot;keyword&quot;  &#125;, </span><br><span class="line">      &quot;create_at&quot;:  &#123; &quot;type&quot;: &quot;date&quot;, &quot;format&quot;:&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;&#125;, </span><br><span class="line">      &quot;phone&quot;:   &#123; &quot;type&quot;: &quot;keyword&quot;  &#125;,</span><br><span class="line">      &quot;address&quot;:   &#123; &quot;type&quot;: &quot;text&quot;  &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-5-查询索引的映射规则"><a href="#2-9-5-查询索引的映射规则" class="headerlink" title="2.9.5 查询索引的映射规则"></a>2.9.5 查询索引的映射规则</h3><p>如果想知道索引的映射规则（索引结构）是怎么样的，可以通过下面语法查询。</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;索引名&#x2F;_mapping</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子：查询上面的订单索引的映射规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order&#x2F;_mapping</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;order&quot; : &#123;</span><br><span class="line">    &quot;mappings&quot; : &#123;</span><br><span class="line">      &quot;properties&quot; : &#123;</span><br><span class="line">        &quot;address&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;text&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;create_at&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;date&quot;,</span><br><span class="line">          &quot;format&quot; : &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;id&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;order_no&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;phone&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;keyword&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;shop_id&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;integer&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;user_id&quot; : &#123;</span><br><span class="line">          &quot;type&quot; : &quot;integer&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-9-6-JSON嵌套类型定义"><a href="#2-9-6-JSON嵌套类型定义" class="headerlink" title="2.9.6 JSON嵌套类型定义"></a>2.9.6 JSON嵌套类型定义</h3><p>例如下面json，我们如何在ES中定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	&quot;order_no&quot; : &quot;20200313120000123123&quot;,</span><br><span class="line">	&quot;shop_id&quot; : 12,</span><br><span class="line">	&quot;user&quot; : &#123;</span><br><span class="line">		&quot;id&quot; : 100,</span><br><span class="line">		&quot;nickname&quot; : &quot;dacui&quot;,</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里user属性是一个Object类型，json类型本身支持这种通过对象无线嵌套的结构。</p>
<p>ES的映射也支持Object类型，嵌套json的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;order_v2</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123; &#x2F;&#x2F; 第一层json属性定义</span><br><span class="line">      &quot;order_no&quot;:  &#123; &quot;type&quot;: &quot;keyword&quot;  &#125;, </span><br><span class="line">      &quot;shop_id&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,  </span><br><span class="line">      &quot;user&quot;: &#123; &#x2F;&#x2F; user属性是Object类型，可以单独定义属性类型</span><br><span class="line">      	&quot;properties&quot; : &#123; &#x2F;&#x2F; 第二层user对象的属性定义</span><br><span class="line">      		&quot;id&quot;:    &#123; &quot;type&quot;: &quot;integer&quot; &#125;,</span><br><span class="line">      		&quot;nickname&quot;:  &#123; &quot;type&quot;: &quot;text&quot; &#125;</span><br><span class="line">      	&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上面例子，如果属性是Object类型只要使用properties单独定义即可支持多层Json对象嵌套。</p>
<h2 id="2-10-查询语法"><a href="#2-10-查询语法" class="headerlink" title="2.10 查询语法"></a>2.10 查询语法</h2><p>通过ES查询表达式(Query DSL)，可以实现复杂的查询功能，ES查询表达式主要由JSON格式编写，可以灵活的组合各种查询语句。</p>
<h3 id="2-10-1-查询基本语法结构"><a href="#2-10-1-查询基本语法结构" class="headerlink" title="2.10.1 查询基本语法结构"></a>2.10.1 查询基本语法结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;from&quot; : 0,  &#x2F;&#x2F; 返回搜索结果的开始位置</span><br><span class="line">  	&quot;size&quot; : 10, &#x2F;&#x2F; 分页大小，一次返回多少数据</span><br><span class="line">  	&quot;_source&quot; :[ ...需要返回的字段数组... ],</span><br><span class="line">	&quot;query&quot; : &#123; ...query子句... &#125;,</span><br><span class="line">	&quot;aggs&quot; : &#123; ..aggs子句..  &#125;,</span><br><span class="line">	&quot;sort&quot; : &#123; ..sort子句..  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>{索引名}，支持支持一次搜索多个索引，多个索引使用逗号分隔，例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order1,order2&#x2F;_search</span><br></pre></td></tr></table></figure>

<p>按前缀匹配索引名：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order*&#x2F;_search</span><br></pre></td></tr></table></figure>

<p>搜索索引名以order开头的索引。</p>
<p>查询结果格式：</p>
<p>当我们执行查询语句，返回的JSON数据格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;took&quot; : 5, &#x2F;&#x2F; 查询消耗时间，单位毫秒 </span><br><span class="line">  &quot;timed_out&quot; : false, &#x2F;&#x2F; 查询是否超时</span><br><span class="line">  &quot;_shards&quot; : &#123; &#x2F;&#x2F; 本次查询参与的ES分片信息，查询中参与分片的总数，以及这些分片成功了多少个失败了多少个</span><br><span class="line">    &quot;total&quot; : 1,</span><br><span class="line">    &quot;successful&quot; : 1,</span><br><span class="line">    &quot;skipped&quot; : 0,</span><br><span class="line">    &quot;failed&quot; : 0</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;hits&quot; : &#123; &#x2F;&#x2F; hits字段包含我们搜索匹配的结果</span><br><span class="line">    &quot;total&quot; : &#123; &#x2F;&#x2F; 匹配到的文档总数</span><br><span class="line">      &quot;value&quot; : 1, &#x2F;&#x2F; 找到1个文档</span><br><span class="line">      &quot;relation&quot; : &quot;eq&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_score&quot; : 1.0, &#x2F;&#x2F; 匹配到的最大分值</span><br><span class="line">    &quot;hits&quot; : [ </span><br><span class="line">         &#x2F;&#x2F; 这里就是我们具体的搜索结果，是一个JSON文档数组</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-10-2-query子句"><a href="#2-10-2-query子句" class="headerlink" title="2.10.2 query子句"></a>2.10.2 query子句</h3><p>query子句主要用来编写类似SQL的Where语句，支持布尔查询（and/or）、IN、全文搜索、模糊匹配、范围查询（大于小于）。</p>
<h3 id="2-10-3-aggs子句"><a href="#2-10-3-aggs子句" class="headerlink" title="2.10.3 aggs子句"></a>2.10.3 aggs子句</h3><p>aggs子句，主要用来编写统计分析语句，类似SQL的group by语句</p>
<h3 id="2-10-4-sort子句"><a href="#2-10-4-sort子句" class="headerlink" title="2.10.4 sort子句"></a>2.10.4 sort子句</h3><p>sort子句，用来设置排序条件，类似SQL的order by语句</p>
<h3 id="2-10-5-ES查询分页"><a href="#2-10-5-ES查询分页" class="headerlink" title="2.10.5 ES查询分页"></a>2.10.5 ES查询分页</h3><p>ES查询的分页主要通过from和size参数设置，类似MYSQL 的limit和offset语句</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;from&quot;: 0,</span><br><span class="line">  &quot;size&quot;: 20, </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询所有数据，从第0条数据开始，一次返回20条数据。</p>
<h3 id="2-10-6-source"><a href="#2-10-6-source" class="headerlink" title="2.10.6 _source"></a>2.10.6 _source</h3><p>_source用于设置查询结果返回什么字段，类似Select语句后面指定字段。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: [&quot;order_no&quot;,&quot;shop_id&quot;], </span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>仅返回，order_no和shop_id字段。</p>
<h2 id="2-11-query查询语法"><a href="#2-11-query查询语法" class="headerlink" title="2.11 query查询语法"></a>2.11 query查询语法</h2><p>query子句主要用于编写查询条件，类似SQL中的where语句</p>
<h3 id="2-11-1-匹配单个字段"><a href="#2-11-1-匹配单个字段" class="headerlink" title="2.11.1 匹配单个字段"></a>2.11.1 匹配单个字段</h3><p>通过match实现全文搜索，全文搜索的后面有单独的章节讲解，这里大家只要知道简单的用法就可以。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;&#123;FIELD&#125;&quot;: &quot;&#123;TEXT&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>{FIELD} - 就是我们需要匹配的字段名</li>
<li>{TEXT} - 就是我们需要匹配的内容</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;article&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;title&quot; : &quot;ES教程&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>article索引中，title字段匹配<strong>ES教程</strong>的所有文档。</p>
<p>如果title字段的数据类型是text类型，搜索关键词会进行分词处理。</p>
<h3 id="2-11-2-精确匹配单个字段"><a href="#2-11-2-精确匹配单个字段" class="headerlink" title="2.11.2 精确匹配单个字段"></a>2.11.2 精确匹配单个字段</h3><p>如果我们想要类似SQL语句中的<strong>等值</strong>匹配，不需要进行分词处理，例如：订单号、手机号、时间字段，不需要分值处理，只要精确匹配。</p>
<p>通过term实现精确匹配语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;&#123;FIELD&#125;&quot;: &quot;&#123;VALUE&#125;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>{FIELD} - 就是我们需要匹配的字段名</li>
<li>{VALUE} - 就是我们需要匹配的内容，除了TEXT类型字段以外的任意类型。</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;order_no&quot;: &quot;202003131209120999&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索订单号order_no = “202003131209120999”的文档。</p>
<p>类似SQL语句:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where order_no &#x3D; &quot;202003131209120999&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-11-3-通过terms实现SQL的in语句"><a href="#2-11-3-通过terms实现SQL的in语句" class="headerlink" title="2.11.3 通过terms实现SQL的in语句"></a>2.11.3 通过terms实现SQL的in语句</h3><p>如果我们要实现SQL中的in语句，一个字段包含给定数组中的任意一个值就匹配。</p>
<p>terms语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">      &quot;&#123;FIELD&#125;&quot;: [</span><br><span class="line">        &quot;&#123;VALUE1&#125;&quot;,</span><br><span class="line">        &quot;&#123;VALUE2&#125;&quot;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>说明：</p>
<ul>
<li>{FIELD} - 就是我们需要匹配的字段名</li>
<li>{VALUE1}, {VALUE2} …. {VALUE N} - 就是我们需要匹配的内容，除了TEXT类型字段以外的任意类型。</li>
</ul>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">      &quot;shop_id&quot;: [123,100,300]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索order_v2索引中，shop_id字段，只要包含[123,100,300]其中一个值，就算匹配。</p>
<p>类似SQL语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where shop_id in (123,100,300)</span><br></pre></td></tr></table></figure>

<h3 id="2-11-4-范围查询"><a href="#2-11-4-范围查询" class="headerlink" title="2.11.4 范围查询"></a>2.11.4 范围查询</h3><p>通过range实现范围查询，类似SQL语句中的&gt;, &gt;=, &lt;, &lt;=表达式。</p>
<p>range语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;&#123;FIELD&#125;&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 10, </span><br><span class="line">        &quot;lte&quot;: 20</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>{FIELD} - 字段名</li>
<li>gte范围参数 - 等价于&gt;=</li>
<li>lte范围参数 - 等价于 &lt;=</li>
<li>范围参数可以只写一个，例如：仅保留 “gte”: 10， 则代表 FIELD字段 &gt;= 10</li>
</ul>
<p>范围参数如下：</p>
<ul>
<li><strong>gt</strong> - 大于 （ &gt; ）</li>
<li><strong>gte</strong> - 大于且等于 （ &gt;= ）</li>
<li><strong>lt</strong> - 小于 （ &lt; ）</li>
<li><strong>lte</strong> - 小于且等于 （ &lt;= ）</li>
</ul>
<p>例子1:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;shop_id&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 10,</span><br><span class="line">        &quot;lte&quot;: 200</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询order_v2索引中，shop_id &gt;= 10 且 shop_id &lt;= 200的文档</p>
<p>类似SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where shop_id &gt;&#x3D; 10 and shop_id &lt;&#x3D; 200</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;shop_id&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: 10      </span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where shop_id &gt;&#x3D; 10</span><br></pre></td></tr></table></figure>

<h3 id="2-11-5-bool组合查询"><a href="#2-11-5-bool组合查询" class="headerlink" title="2.11.5 bool组合查询"></a>2.11.5 bool组合查询</h3><p>前面的例子都是设置单个字段的查询条件，如果需要编写类似SQL的Where语句，组合多个字段的查询条件，可以使用bool语句。</p>
<p>（1）bool查询基本语法结构</p>
<p>在ES中bool查询就是用来组合布尔查询条件，布尔查询条件，就是类似SQL中的and （且）、or （或）。</p>
<p>在SQL中，我们需要and和or，还有括号来组合查询条件，在ES中使用bool查询可用做到同样的效果。</p>
<p>bool语法结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123; &#x2F;&#x2F; bool查询</span><br><span class="line">      &quot;must&quot;: [], &#x2F;&#x2F; must条件，类似SQL中的and, 代表必须匹配条件</span><br><span class="line">      &quot;must_not&quot;: [], &#x2F;&#x2F; must_not条件，跟must相反，必须不匹配条件</span><br><span class="line">      &quot;should&quot;: [] &#x2F;&#x2F; should条件，类似SQL中or, 代表匹配其中一个条件</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以任意选择must、must_not和should条件的参数都是一个数组，意味着他们都支持设置多个条件。</p>
<p>提示：前面介绍的单个字段的匹配语句，都可以用在bool查询语句中进行组合。</p>
<p>（2）must条件</p>
<p>类似SQL的and，代表必须匹配的条件。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">         &#123;匹配条件1&#125;,</span><br><span class="line">         &#123;匹配条件2&#125;,</span><br><span class="line">         ...可以有N个匹配条件...</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;order_no&quot;:  &quot;202003131209120999&quot;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;shop_id&quot;:  123</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的Must条件，使用了term精确匹配。</p>
<p>等价SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where order_no&#x3D;&quot;202003131209120999&quot; and shop_id&#x3D;123</span><br></pre></td></tr></table></figure>

<p>（3）must_not条件</p>
<p>跟must的作用相反。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">         &#123;匹配条件1&#125;,</span><br><span class="line">         &#123;匹配条件2&#125;,</span><br><span class="line">         ...可以有N个匹配条件...</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;shop_id&quot;: 1</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;term&quot;: &#123;</span><br><span class="line">              &quot;shop_id&quot;:  2</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价sql:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where shop_id !&#x3D; 1 and shop_id !&#x3D; 2</span><br></pre></td></tr></table></figure>

<p>（4）should条件</p>
<p>类似SQL中的 or， 只要匹配其中一个条件即可</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line"> &#123;</span><br><span class="line">   &quot;query&quot;: &#123;</span><br><span class="line">     &quot;bool&quot;: &#123;</span><br><span class="line">       &quot;should&quot;: [</span><br><span class="line">          &#123;匹配条件1&#125;,</span><br><span class="line">          &#123;匹配条件2&#125;,</span><br><span class="line">          …可以有N个匹配条件…</span><br><span class="line">         ]</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;order_no&quot;: &quot;202003131209120999&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;order_no&quot;: &quot;22222222222222222&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价SQL:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where order_no&#x3D;&quot;202003131209120999&quot; or order_no&#x3D;&quot;22222222222222222&quot;</span><br></pre></td></tr></table></figure>

<p>（5）bool综合例子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;bool&quot;: &#123;</span><br><span class="line">            &quot;must&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;term&quot;: &#123;</span><br><span class="line">                  &quot;order_no&quot;: &quot;2020031312091209991&quot;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;range&quot;: &#123;</span><br><span class="line">                  &quot;shop_id&quot;: &#123;</span><br><span class="line">                    &quot;gte&quot;: 10,</span><br><span class="line">                    &quot;lte&quot;: 200</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;terms&quot;: &#123;</span><br><span class="line">            &quot;tag&quot;: [</span><br><span class="line">              1,</span><br><span class="line">              2,</span><br><span class="line">              3,</span><br><span class="line">              4,</span><br><span class="line">              5,</span><br><span class="line">              12</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 where (order_no&#x3D;&#39;202003131209120999&#39; and (shop_id&gt;&#x3D;10 and shop_id&lt;&#x3D;200)) or tag in (1,2,3,4,5)</span><br></pre></td></tr></table></figure>

<h2 id="2-12-全文搜索"><a href="#2-12-全文搜索" class="headerlink" title="2.12 全文搜索"></a>2.12 全文搜索</h2><p>全文搜索是ES的关键特性之一，平时我们使用SQL的like语句，搜索一些文本、字符串是否包含指定的关键词，但是如果两篇文章，都包含我们的关键词，具体那篇文章内容的相关度更高？ 这个SQL的like语句是做不到的，更别说like语句的性能问题了。</p>
<p>ES通过分词处理、相关度计算可以解决这个问题，ES内置了一些相关度算法，例如：TF/IDF算法，大体上思想就是，如果一个关键词在一篇文章出现的频率高，并且在其他文章中出现的少，那说明这个关键词与这篇文章的相关度很高。</p>
<p><strong>分词的目的：</strong></p>
<p>主要就是为了提取搜索关键词，理解搜索的意图，我们平时在百度搜索内容的时候，输入的内容可能很长，但不是每个字都对搜索有帮助，所以通过分词算法，我们输入的搜索关键词，会进一步分解成多个关键词，例如：搜索输入 “上海陆家嘴在哪里？”，分词算法可能分解出：“上海、陆家嘴、哪里”，具体会分解出什么关键词，跟具体的分词算法有关。</p>
<h3 id="2-12-1-默认全文搜索"><a href="#2-12-1-默认全文搜索" class="headerlink" title="2.12.1 默认全文搜索"></a>2.12.1 默认全文搜索</h3><p>默认情况下，使用全文搜索很简单，只要将字段类型定义为text类型，然后用<strong>match语句</strong>匹配即可。</p>
<p>ES对于text类型的字段，在插入数据的时候，会进行分词处理，然后根据分词的结果索引文档，当我们搜索text类型字段的时候，也会先对搜索关键词进行分词处理、然后根据分词的结果去搜索。</p>
<p>ES默认的分词器是standard，对英文比较友好，例如：hello world 会被分解成 hello和world两个关键词，如果是中文会分解成一个一个字，例如：上海大学 会分解成: 上、海、大、学。</p>
<p>在ES中，我们可以通过下面方式测试分词效果：</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;需要分词的内容&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;分词器&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;hello wolrd&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用standard分词器，对hello world进行分词，下面是输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;hello&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;wolrd&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 6,</span><br><span class="line">      &quot;end_offset&quot; : 11,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>token就是分解出来的关键词。</p>
<p>下面是对中文分词的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;上海大学&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;standard&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;上&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 1,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;海&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 1,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;大&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;学&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 3,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;IDEOGRAPHIC&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>明显被切割成一个个的字了。</p>
<p>中文关键词被分解成一个个的字的主要问题就是搜索结果可能不太准确。</p>
<p>例如：</p>
<p>搜索：上海大学</p>
<p>分词结果：上、海、大、学</p>
<p>下面的内容都会被搜到：</p>
<ul>
<li>上海大学</li>
<li>海上有条船</li>
<li>上海有好吃的</li>
<li>这条船又大又好看</li>
</ul>
<p>基本上包含这四个字的内容都会被搜到，区别就是相关度的问题，这里除了第一条是相关的，后面的内容基本上跟搜索目的没什么关系。</p>
<h3 id="2-12-2-中文分词器"><a href="#2-12-2-中文分词器" class="headerlink" title="2.12.2 中文分词器"></a>2.12.2 中文分词器</h3><p>ES默认的analyzer（分词器），对英文单词比较友好，对中文分词效果不好。不过ES支持安装分词插件，增加新的分词器。</p>
<p>（1）如何指定analyzer</p>
<p>默认的分词器不满足需要，可以在定义索引映射的时候，指定text字段的分词器<br>（analyzer）。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;article</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;title&quot;:   &#123; </span><br><span class="line">          &quot;type&quot;: &quot;text&quot;,</span><br><span class="line">          &quot;analyzer&quot;: &quot;smartcn&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要在定义text字段的时候，增加一个analyzer配置，指定分词器即可，这里指定的分词器是smartcn，后面会介绍怎么安装smartcn插件。</p>
<p>目前中文分词器比较常用的有：smartcn和ik两种， 下面分别介绍这两种分词器。</p>
<p>（2）smartcn分词器</p>
<p>smartcn是目前ES官方推荐的中文分词插件，不过目前不支持自定义词库。</p>
<p>插件安装方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;ES安装目录&#125;&#x2F;bin&#x2F;elasticsearch-plugin install analysis-smartcn</span><br></pre></td></tr></table></figure>

<p>安装完成后，重启ES即可。</p>
<p>smartcn的分词器名字就叫做：smartcn</p>
<p>（3）smartcn中文分词效果</p>
<p>测试分词效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;红烧牛肉面&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;smartcn&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;红烧&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;牛肉面&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 5,</span><br><span class="line">      &quot;type&quot; : &quot;word&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>红烧牛肉面，被切割为: 红烧、牛肉面 两个词。</p>
<p>（4）ik分词器</p>
<p>ik支持自定义扩展词库，有时候分词的结果不满足我们业务需要，需要根据业务设置专门的词库，词库的作用就是自定义一批关键词，分词的时候优先根据词库设置的关键词分割内容，例如：词库中包含 “上海大学” 关键词，如果对“上海大学在哪里？”进行分词，“上海大学” 会做为一个整体被切割出来。</p>
<p>安装ik插件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 到这里找跟自己ES版本一致的插件地址</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases</span><br></pre></td></tr></table></figure>

<p>我本地使用的ES版本是7.5.1，所以选择的Ik插件版本地址是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v7.5.1&#x2F;elasticsearch-analysis-ik-7.5.1.zip</span><br></pre></td></tr></table></figure>

<p>当然你也可以尝试根据我给出这个地址，直接修改版本号，试试看行不行。</p>
<p>安装命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;ES安装目录&#125;&#x2F;bin&#x2F;elasticsearch-plugin install https:&#x2F;&#x2F;github.com&#x2F;medcl&#x2F;elasticsearch-analysis-ik&#x2F;releases&#x2F;download&#x2F;v7.5.1&#x2F;elasticsearch-analysis-ik-7.5.1.zip</span><br></pre></td></tr></table></figure>

<p>（5）ik中文分词效果</p>
<p>ik分词插件支持 ik_smart 和 ik_max_word 两种分词器</p>
<ul>
<li>ik_smart - 粗粒度的分词</li>
<li>ik_max_word - 会尽可能的枚举可能的关键词，就是分词比较细致一些，会分解出更多的关键词</li>
</ul>
<p>例1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;上海人民广场麻辣烫&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_max_word&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;上海人&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 3,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;上海&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;人民&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;广场&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 6,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;麻辣烫&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 6,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 4</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;麻辣&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 6,</span><br><span class="line">      &quot;end_offset&quot; : 8,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 5</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;烫&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 8,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;CN_CHAR&quot;,</span><br><span class="line">      &quot;position&quot; : 6</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;text&quot;: &quot;上海人民广场麻辣烫&quot;,</span><br><span class="line">  &quot;analyzer&quot;: &quot;ik_smart&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;上海&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 0,</span><br><span class="line">      &quot;end_offset&quot; : 2,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 0</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;人民&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 2,</span><br><span class="line">      &quot;end_offset&quot; : 4,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 1</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;广场&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 4,</span><br><span class="line">      &quot;end_offset&quot; : 6,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 2</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;麻辣烫&quot;,</span><br><span class="line">      &quot;start_offset&quot; : 6,</span><br><span class="line">      &quot;end_offset&quot; : 9,</span><br><span class="line">      &quot;type&quot; : &quot;CN_WORD&quot;,</span><br><span class="line">      &quot;position&quot; : 3</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（6）ik自定义词库</p>
<p>自定义扩展词库步骤如下：</p>
<p>一、创建配词库文件，以dic作为扩展名</p>
<p>例如：词库文件：{ES安装目录}/analysis-ik/config/demo.dic</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上海大学</span><br><span class="line">复旦大学</span><br><span class="line">人民广场</span><br></pre></td></tr></table></figure>

<p>一行一个词条即可</p>
<p>提示：config目录不存在创建一个即可。</p>
<p>二、创建或者修改配置文件</p>
<p>配置文件路径：{ES安装目录}/analysis-ik/config/IKAnalyzer.cfg.xml</p>
<p>IKAnalyzer.cfg.xml配置文件不存在，就创建一个。</p>
<p>配置文件内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE properties SYSTEM &quot;http:&#x2F;&#x2F;java.sun.com&#x2F;dtd&#x2F;properties.dtd&quot;&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">	&lt;comment&gt;IK Analyzer 扩展配置&lt;&#x2F;comment&gt;</span><br><span class="line">	&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span><br><span class="line">	&lt;entry key&#x3D;&quot;ext_dict&quot;&gt;&#123;ES安装目录&#125;&#x2F;analysis-ik&#x2F;config&#x2F;demo.dic&lt;&#x2F;entry&gt;</span><br><span class="line">	 &lt;!--用户可以在这里配置自己的扩展停止词字典，没有可用删掉配置--&gt;</span><br><span class="line">	&lt;entry key&#x3D;&quot;ext_stopwords&quot;&gt;custom&#x2F;ext_stopword.dic&lt;&#x2F;entry&gt;</span><br><span class="line"> 	&lt;!--用户可以在这里配置远程扩展字典，这个配置需要结合下面配置一起使用，没有可用删掉配置 --&gt;</span><br><span class="line">	&lt;entry key&#x3D;&quot;remote_ext_dict&quot;&gt;location&lt;&#x2F;entry&gt;</span><br><span class="line"> 	&lt;!--用户可以在这里配置远程扩展停止词字典，没有可用删掉--&gt;</span><br><span class="line">	&lt;entry key&#x3D;&quot;remote_ext_stopwords&quot;&gt;http:&#x2F;&#x2F;xxx.com&#x2F;xxx.dic&lt;&#x2F;entry&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br></pre></td></tr></table></figure>

<p>三、重启ES即可</p>
<p>提示：Ik新增扩展词库，支持热更新，不用重启ES，使用remote_ext_dict和remote_ext_stopwords配置远程词库地址即可，词库地址需要返回两个头部(header)，一个是 <code>Last-Modified</code>，一个是 <code>ETag</code>，ES靠这两个头识别是否需要更新词库，不了解这两个HTTP头，可以搜一下。</p>
<h2 id="2-13-sort排序子句"><a href="#2-13-sort排序子句" class="headerlink" title="2.13 sort排序子句"></a>2.13 sort排序子句</h2><p>ES的默认排序是根据相关性分数排序，如果我们想根据查询结果中的指定字段排序，需要使用sort Processors处理。</p>
<p>sort语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;&#123;索引名&#125;&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    ...查询条件....</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;&#123;Field1&#125;&quot;: &#123; &#x2F;&#x2F; 排序字段1</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot; &#x2F;&#x2F; 排序方向，asc或者desc, 升序和降序</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;&#123;Field2&#125;&quot;: &#123; &#x2F;&#x2F; 排序字段2</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot; &#x2F;&#x2F; 排序方向，asc或者desc, 升序和降序</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ....多个排序字段.....</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sort子句支持多个字段排序，类似SQL的order by。</p>
<p>例子1：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;order_no&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;shop_id&quot;: &#123;</span><br><span class="line">        &quot;order&quot;: &quot;asc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询order_v2索引的所有结果，结果根据order_no字段降序，order_no相等的时候，再根据shop_id字段升序排序。</p>
<p>类似SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from order_v2 order by order_no desc, shop_id asc</span><br></pre></td></tr></table></figure>

<p>例子2：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order_v2&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_all&quot;: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;user.id&quot;: &#123; &#x2F;&#x2F; 嵌套json对象，使用 点 连接字段名即可</span><br><span class="line">        &quot;order&quot;: &quot;desc&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-14-聚合查询（aggs）"><a href="#2-14-聚合查询（aggs）" class="headerlink" title="2.14 聚合查询（aggs）"></a>2.14 聚合查询（aggs）</h2><p>ES中的聚合查询，类似SQL的SUM/AVG/COUNT/GROUP BY分组查询，主要用于统计分析场景。</p>
<p>下面先介绍ES聚合查询的核心流程和核心概念。</p>
<h3 id="2-14-1-ES聚合查询流程"><a href="#2-14-1-ES聚合查询流程" class="headerlink" title="2.14.1 ES聚合查询流程"></a>2.14.1 ES聚合查询流程</h3><p>ES聚合查询类似SQL的GROUP by，一般统计分析主要分为两个步骤：</p>
<ul>
<li>分组</li>
<li>组内聚合</li>
</ul>
<p>对查询的数据首先进行一轮分组，可以设置分组条件，例如：新生入学，把所有的学生按专业分班，这个分班的过程就是对学生进行了分组。</p>
<p>组内聚合，就是对组内的数据进行统计，例如：计算总数、求平均值等等，接上面的例子，学生都按专业分班了，那么就可以统计每个班的学生总数， 这个统计每个班学生总数的计算，就是组内聚合计算。</p>
<p>提示：分组类似SQL的group by语句设定的条件，组内聚合，就是在select编写的avg、sum、count统计函数；熟悉SQL语句都知道sum、count这些统计函数不一定要跟group by语句配合使用，单独使用统计函数等同于将所有数据分成一个组，直接对所有数据进行统计。</p>
<h3 id="2-14-2-核心概念"><a href="#2-14-2-核心概念" class="headerlink" title="2.14.2 核心概念"></a>2.14.2 核心概念</h3><p>通过上面的聚合查询流程，下面是ES聚合的核心概念就很容易理解了</p>
<p>（1）桶</p>
<p>满足特定条件的文档的集合，叫做桶。</p>
<p>桶的就是一组数据的集合，对数据分组后，得到一组组的数据，就是一个个的桶。</p>
<p>提示：桶等同于组，分桶和分组是一个意思，ES使用桶代表一组相同特征的数据。</p>
<p>ES中桶聚合，指的就是先对数据进行分组，ES支持多种分组条件，例如：支持类似SQL的group by根据字段分组，当然ES比SQL更强大，支持更多的分组条件，以满足各种统计需求。</p>
<p>（2）指标</p>
<p>指标指的是对文档进行统计计算方式，又叫指标聚合。</p>
<p>桶内聚合，说的就是先对数据进行分组（分桶），然后对每一个桶内的数据进行指标聚合。</p>
<p>说白了就是，前面将数据经过一轮桶聚合，把数据分成一个个的桶之后，我们根据上面计算指标对桶内的数据进行统计。</p>
<p>常用的指标有：SUM、COUNT、MAX等统计函数。</p>
<p>借助SQL的统计语句理解桶和指标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT COUNT(*) </span><br><span class="line">FROM order</span><br><span class="line">GROUP BY shop_id </span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>COUNT(*) 相当于指标, 也叫统计指标。</li>
<li>GROUP BY shop_id 相当于分桶的条件，也可以叫分组条件，相同shop_id的数据都分到一个桶内。</li>
</ul>
<p>这条SQL语句的作用就是统计每一个店铺的订单数，所以SQL统计的第一步是根据group by shop_id这个条件，把shop_id（店铺ID）相同的数据分到一个组（桶）里面，然后每一组数据使用count(*)统计函数（指标）计算总数，最终得到每一个店铺的订单总数，ES也是类似的过程。</p>
<h3 id="2-14-3-ES聚合查询语法"><a href="#2-14-3-ES聚合查询语法" class="headerlink" title="2.14.3 ES聚合查询语法"></a>2.14.3 ES聚合查询语法</h3><p>大家可以先大致了解下ES聚合查询的基本语法结构，后面的章节会介绍具体的用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;aggregations&quot; : &#123;</span><br><span class="line">    &quot;&lt;aggregation_name&gt;&quot; : &#123;</span><br><span class="line">        &quot;&lt;aggregation_type&gt;&quot; : &#123;</span><br><span class="line">            &lt;aggregation_body&gt;</span><br><span class="line">        &#125;</span><br><span class="line">        [,&quot;aggregations&quot; : &#123; [&lt;sub_aggregation&gt;]+ &#125; ]? &#x2F;&#x2F; 嵌套聚合查询，支持多层嵌套</span><br><span class="line">    &#125;</span><br><span class="line">    [,&quot;&lt;aggregation_name_2&gt;&quot; : &#123; ... &#125; ]* &#x2F;&#x2F; 多个聚合查询，每个聚合查询取不同的名字</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><strong>aggregations</strong> - 代表聚合查询语句，可以简写为aggs</li>
<li><strong><aggregation_name></strong> - 代表一个聚合计算的名字，可以随意命名，因为ES支持一次进行多次统计分析查询，后面需要通过这个名字在查询结果中找到我们想要的计算结果。</li>
<li><strong><aggregation_type></strong> - 聚合类型，代表我们想要怎么统计数据，主要有两大类聚合类型，桶聚合和指标聚合，这两类聚合又包括多种聚合类型，例如：指标聚合：sum、avg， 桶聚合：terms、Date histogram等等。</li>
<li><strong><aggregation_body></strong> - 聚合类型的参数，选择不同的聚合类型，有不同的参数。</li>
<li><strong>aggregation_name_2</strong> - 代表其他聚合计算的名字，意思就是可以一次进行多种类型的统计。</li>
</ul>
<p>下面看个简单的聚合查询的例子：</p>
<p>假设存在一个order索引，存储了每一笔汽车销售订单，里面包含了汽车颜色字段color.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0, &#x2F;&#x2F; 设置size&#x3D;0的意思就是，仅返回聚合查询结果，不返回普通query查询结果。</span><br><span class="line">    &quot;aggs&quot; : &#123; &#x2F;&#x2F; 聚合查询语句的简写</span><br><span class="line">        &quot;popular_colors&quot; : &#123; &#x2F;&#x2F; 给聚合查询取个名字，叫popular_colors</span><br><span class="line">            &quot;terms&quot; : &#123; &#x2F;&#x2F; 聚合类型为，terms，terms是桶聚合的一种，类似SQL的group by的作用，根据字段分组，相同字段值的文档分为一组。</span><br><span class="line">              &quot;field&quot; : &quot;color&quot; &#x2F;&#x2F; terms聚合类型的参数，这里需要设置分组的字段为color，根据color分组</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面使用了terms桶聚合，而且没有明确指定指标聚合函数，默认使用的是Value Count聚合指标统计文档总数， 整个统计的意思是统计每一种汽车颜色的销量。</p>
<p>等价SQL如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(color) from order group by color</span><br></pre></td></tr></table></figure>

<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">   &quot;hits&quot;: &#123; &#x2F;&#x2F; 因为size&#x3D;0,所以query查询结果为空</span><br><span class="line">      &quot;hits&quot;: [] </span><br><span class="line">   &#125;,</span><br><span class="line">   &quot;aggregations&quot;: &#123; &#x2F;&#x2F; 聚合查询结果</span><br><span class="line">      &quot;popular_colors&quot;: &#123; &#x2F;&#x2F; 这个就是popular_colors聚合查询的结果，这就是为什么需要给聚合查询取个名字的原因，如果有多个聚合查询，可以通过名字查找结果</span><br><span class="line">         &quot;buckets&quot;: [ &#x2F;&#x2F; 因为是桶聚合，所以看到返回一个buckets数组，代表分组的统计情况，下面可以看到每一种颜色的销量情况</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;key&quot;: &quot;red&quot;, </span><br><span class="line">               &quot;doc_count&quot;: 4 &#x2F;&#x2F; 红色的汽车销量为4</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;key&quot;: &quot;blue&quot;,</span><br><span class="line">               &quot;doc_count&quot;: 2</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               &quot;key&quot;: &quot;green&quot;,</span><br><span class="line">               &quot;doc_count&quot;: 2</span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-15-指标聚合（metrics）"><a href="#2-15-指标聚合（metrics）" class="headerlink" title="2.15 指标聚合（metrics）"></a>2.15 指标聚合（metrics）</h2><p>ES指标聚合，就是类似SQL的统计函数，指标聚合可以单独使用，也可以跟桶聚合一起使用。</p>
<p>常用的统计函数如下：</p>
<ul>
<li>Value Count - 类似sql的count函数，统计总数</li>
<li>Cardinality - 类似SQL的count(DISTINCT 字段)， 统计不重复的数据总数</li>
<li>Avg - 求平均值</li>
<li>Sum - 求和</li>
<li>Max - 求最大值</li>
<li>Min - 求最小值</li>
</ul>
<p>下面分别介绍Elasticsearch常用统计函数的用法。</p>
<h3 id="2-15-1-Value-Count"><a href="#2-15-1-Value-Count" class="headerlink" title="2.15.1 Value Count"></a>2.15.1 Value Count</h3><p>值聚合，主要用于统计文档总数，类似SQL的count函数。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;types_count&quot;: &#123; &#x2F;&#x2F; 聚合查询的名字，随便取个名字</span><br><span class="line">      &quot;value_count&quot;: &#123; &#x2F;&#x2F; 聚合类型为：value_count</span><br><span class="line">        &quot;field&quot;: &quot;type&quot; &#x2F;&#x2F; 计算type这个字段值的总数</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(type) from sales</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;types_count&quot;: &#123; &#x2F;&#x2F; 聚合查询的名字</span><br><span class="line">            &quot;value&quot;: 7 &#x2F;&#x2F; 统计结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-15-2-Cardinality"><a href="#2-15-2-Cardinality" class="headerlink" title="2.15.2 Cardinality"></a>2.15.2 Cardinality</h3><p>基数聚合，也是用于统计文档的总数，跟Value Count的区别是，基数聚合会去重，不会统计重复的值，类似SQL的count(DISTINCT 字段)用法。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;type_count&quot; : &#123; &#x2F;&#x2F; 聚合查询的名字，随便取一个</span><br><span class="line">            &quot;cardinality&quot; : &#123; &#x2F;&#x2F; 聚合查询类型为：cardinality</span><br><span class="line">                &quot;field&quot; : &quot;type&quot; &#x2F;&#x2F; 根据type这个字段统计文档总数</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select count(DISTINCT type) from sales</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot; : &#123;</span><br><span class="line">        &quot;type_count&quot; : &#123; &#x2F;&#x2F; 聚合查询的名字</span><br><span class="line">            &quot;value&quot; : 3 &#x2F;&#x2F; 统计结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：前面提到基数聚合的作用等价于SQL的count(DISTINCT 字段)的用法，其实不太准确，因为SQL的count统计结果是精确统计不会丢失精度，但是ES的cardinality基数聚合统计的总数是一个近似值，会有一定的误差，这么做的目的是为了性能，因为在海量的数据中精确统计总数是非常消耗性能的，但是很多业务场景不需要精确的结果，只要近似值，例如：统计网站一天的访问量，有点误差没关系。</p>
<h3 id="2-15-3-Avg"><a href="#2-15-3-Avg" class="headerlink" title="2.15.3 Avg"></a>2.15.3 Avg</h3><p>求平均值</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;exams&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;avg_grade&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个名字</span><br><span class="line">      &quot;avg&quot;: &#123; &#x2F;&#x2F; 聚合查询类型为: avg</span><br><span class="line">        &quot;field&quot;: &quot;grade&quot; &#x2F;&#x2F; 统计grade字段值的平均值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;avg_grade&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;value&quot;: 75.0 &#x2F;&#x2F; 统计结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-15-4-Sum"><a href="#2-15-4-Sum" class="headerlink" title="2.15.4 Sum"></a>2.15.4 Sum</h3><p>求和计算</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;hat_prices&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个名字</span><br><span class="line">      &quot;sum&quot;: &#123; &#x2F;&#x2F; 聚合类型为：sum</span><br><span class="line">        &quot;field&quot;: &quot;price&quot; &#x2F;&#x2F; 计算price字段值的总和</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;hat_prices&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">           &quot;value&quot;: 450.0 &#x2F;&#x2F; 统计结果</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-15-5-Max"><a href="#2-15-5-Max" class="headerlink" title="2.15.5 Max"></a>2.15.5 Max</h3><p>求最大值</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;max_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字,随便取一个名字</span><br><span class="line">      &quot;max&quot;: &#123; &#x2F;&#x2F; 聚合类型为：max</span><br><span class="line">        &quot;field&quot;: &quot;price&quot; &#x2F;&#x2F; 求price字段的最大值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;max_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;value&quot;: 200.0 &#x2F;&#x2F; 最大值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-15-6-Min"><a href="#2-15-6-Min" class="headerlink" title="2.15.6 Min"></a>2.15.6 Min</h3><p>求最小值</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;min_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个</span><br><span class="line">      &quot;min&quot;: &#123; &#x2F;&#x2F; 聚合类型为: min</span><br><span class="line">        &quot;field&quot;: &quot;price&quot; &#x2F;&#x2F; 求price字段值的最小值</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;min_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;value&quot;: 10.0 &#x2F;&#x2F; 最小值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-15-7-综合例子"><a href="#2-15-7-综合例子" class="headerlink" title="2.15.7 综合例子"></a>2.15.7 综合例子</h3><p>前面的例子，仅仅介绍聚合指标单独使用的情况，实际应用中经常先通过query查询，搜索索引中的数据，然后对query查询的结果进行统计分析。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;sales&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: 0, &#x2F;&#x2F; size &#x3D; 0,代表不想返回query查询结果，只要统计结果</span><br><span class="line">  &quot;query&quot;: &#123; &#x2F;&#x2F; 设置query查询条件，后面的aggs统计，仅对query查询结果进行统计</span><br><span class="line">    &quot;constant_score&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;match&quot;: &#123;</span><br><span class="line">          &quot;type&quot;: &quot;hat&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123; &#x2F;&#x2F; 统计query查询结果, 默认情况如果不写query语句，则代表统计所有数据</span><br><span class="line">    &quot;hat_prices&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，计算price总和</span><br><span class="line">      &quot;sum&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;min_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，计算price最小值</span><br><span class="line">      &quot;min&quot;: &#123; </span><br><span class="line">        &quot;field&quot;: &quot;price&quot; </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;max_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，计算price最大值</span><br><span class="line">      &quot;max&quot;: &#123; </span><br><span class="line">        &quot;field&quot;: &quot;price&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;hat_prices&quot;: &#123; &#x2F;&#x2F; 求和</span><br><span class="line">           &quot;value&quot;: 450.0</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;min_price&quot;: &#123; &#x2F;&#x2F; 最小值</span><br><span class="line">            &quot;value&quot;: 10.0 </span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;max_price&quot;: &#123; &#x2F;&#x2F; 最大值</span><br><span class="line">            &quot;value&quot;: 200.0 </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-16-分组聚合查询-bucket"><a href="#2-16-分组聚合查询-bucket" class="headerlink" title="2.16 分组聚合查询(bucket)"></a>2.16 分组聚合查询(bucket)</h2><p>Elasticsearch桶聚合，目的就是数据分组，先将数据按指定的条件分成多个组，然后对每一个组进行统计。 组的概念跟桶是等同的，在ES中统一使用桶（bucket）这个术语。</p>
<p>ES桶聚合的作用跟SQL的group by的作用是一样的，区别是ES支持更加强大的数据分组能力，SQL只能根据字段的唯一值进行分组，分组的数量跟字段的唯一值的数量相等，例如: group by 店铺id， 去掉重复的店铺ID后，有多少个店铺就有多少个分组。</p>
<p>ES常用的桶聚合如下：</p>
<ul>
<li><strong>Terms聚合</strong> - 类似SQL的group by，根据字段唯一值分组</li>
<li><strong>Histogram聚合</strong> - 根据数值间隔分组，例如: 价格按100间隔分组，0、100、200、300等等</li>
<li><strong>Date histogram聚合</strong> - 根据时间间隔分组，例如：按月、按天、按小时分组</li>
<li><strong>Range聚合</strong> - 按数值范围分组，例如: 0-150一组，150-200一组，200-500一组。</li>
</ul>
<p>提示：桶聚合一般不单独使用，都是配合指标聚合一起使用，对数据分组之后肯定要统计桶内数据，在ES中如果没有明确指定指标聚合，默认使用Value Count指标聚合，统计桶内文档总数。</p>
<h3 id="2-16-1-Terms聚合"><a href="#2-16-1-Terms聚合" class="headerlink" title="2.16.1 Terms聚合"></a>2.16.1 Terms聚合</h3><p>terms聚合的作用跟SQL中group by作用一样，都是根据字段唯一值对数据进行分组（分桶），字段值相等的文档都分到同一个桶内。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;order&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;shop&quot;: &#123; &#x2F;&#x2F; 聚合查询的名字，随便取个名字</span><br><span class="line">      &quot;terms&quot;: &#123; &#x2F;&#x2F; 聚合类型为: terms</span><br><span class="line">        &quot;field&quot;: &quot;shop_id&quot; &#x2F;&#x2F; 根据shop_id字段值，分桶</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>等价SQL：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select shop_id, count(*) from order group by shop_id</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot; : &#123;</span><br><span class="line">        &quot;shop&quot; : &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;buckets&quot; : [ &#x2F;&#x2F; 桶聚合结果，下面返回各个桶的聚合结果</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot; : &quot;1&quot;, &#x2F;&#x2F; key分桶的标识，在terms聚合中，代表的就是分桶的字段值</span><br><span class="line">                    &quot;doc_count&quot; : 6 &#x2F;&#x2F; 默认的指标聚合是统计桶内文档总数</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot; : &quot;5&quot;,</span><br><span class="line">                    &quot;doc_count&quot; : 3</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot; : &quot;9&quot;,</span><br><span class="line">                    &quot;doc_count&quot; : 2</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-16-2-Histogram聚合"><a href="#2-16-2-Histogram聚合" class="headerlink" title="2.16.2 Histogram聚合"></a>2.16.2 Histogram聚合</h3><p>histogram（直方图）聚合，主要根据数值间隔分组，使用histogram聚合分桶统计结果，通常用在绘制条形图报表。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;prices&quot; : &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个</span><br><span class="line">            &quot;histogram&quot; : &#123; &#x2F;&#x2F; 聚合类型为：histogram</span><br><span class="line">                &quot;field&quot; : &quot;price&quot;, &#x2F;&#x2F; 根据price字段分桶</span><br><span class="line">                &quot;interval&quot; : 50 &#x2F;&#x2F; 分桶的间隔为50，意思就是price字段值按50间隔分组</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;prices&quot; : &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;buckets&quot;: [ &#x2F;&#x2F; 分桶结果</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: 0.0, &#x2F;&#x2F; 桶的标识，histogram分桶，这里通常是分组的间隔值</span><br><span class="line">                    &quot;doc_count&quot;: 1 &#x2F;&#x2F; 默认按Value Count指标聚合，统计桶内文档总数</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123; </span><br><span class="line">                    &quot;key&quot;: 50.0,</span><br><span class="line">                    &quot;doc_count&quot;: 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: 100.0,</span><br><span class="line">                    &quot;doc_count&quot;: 0</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: 150.0,</span><br><span class="line">                    &quot;doc_count&quot;: 2</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-16-3-Date-histogram聚合"><a href="#2-16-3-Date-histogram聚合" class="headerlink" title="2.16.3 Date histogram聚合"></a>2.16.3 Date histogram聚合</h3><p>类似histogram聚合，区别是Date histogram可以很好的处理时间类型字段，主要用于根据时间、日期分桶的场景。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;sales&#x2F;_search?size&#x3D;0</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;sales_over_time&quot; : &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个</span><br><span class="line">            &quot;date_histogram&quot; : &#123; &#x2F;&#x2F; 聚合类型为: date_histogram</span><br><span class="line">                &quot;field&quot; : &quot;date&quot;, &#x2F;&#x2F; 根据date字段分组</span><br><span class="line">                &quot;calendar_interval&quot; : &quot;month&quot;, &#x2F;&#x2F; 分组间隔：month代表每月、支持minute（每分钟）、hour（每小时）、day（每天）、week（每周）、year（每年）</span><br><span class="line">                &quot;format&quot; : &quot;yyyy-MM-dd&quot; &#x2F;&#x2F; 设置返回结果中桶key的时间格式</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;sales_over_time&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;buckets&quot;: [ &#x2F;&#x2F; 桶聚合结果</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key_as_string&quot;: &quot;2015-01-01&quot;, &#x2F;&#x2F; 每个桶key的字符串标识，格式由format指定</span><br><span class="line">                    &quot;key&quot;: 1420070400000, &#x2F;&#x2F; key的具体字段值</span><br><span class="line">                    &quot;doc_count&quot;: 3 &#x2F;&#x2F; 默认按Value Count指标聚合，统计桶内文档总数</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key_as_string&quot;: &quot;2015-02-01&quot;,</span><br><span class="line">                    &quot;key&quot;: 1422748800000,</span><br><span class="line">                    &quot;doc_count&quot;: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key_as_string&quot;: &quot;2015-03-01&quot;,</span><br><span class="line">                    &quot;key&quot;: 1425168000000,</span><br><span class="line">                    &quot;doc_count&quot;: 2</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-16-4-Range聚合"><a href="#2-16-4-Range聚合" class="headerlink" title="2.16.4 Range聚合"></a>2.16.4 Range聚合</h3><p>range聚合，按数值范围分桶。</p>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;price_ranges&quot; : &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个</span><br><span class="line">            &quot;range&quot; : &#123; &#x2F;&#x2F; 聚合类型为： range</span><br><span class="line">                &quot;field&quot; : &quot;price&quot;, &#x2F;&#x2F; 根据price字段分桶</span><br><span class="line">                &quot;ranges&quot; : [ &#x2F;&#x2F; 范围配置</span><br><span class="line">                    &#123; &quot;to&quot; : 100.0 &#125;, &#x2F;&#x2F; 意思就是 price &lt;&#x3D; 100的文档归类到一个桶</span><br><span class="line">                    &#123; &quot;from&quot; : 100.0, &quot;to&quot; : 200.0 &#125;, &#x2F;&#x2F; price&gt;100 and price&lt;200的文档归类到一个桶</span><br><span class="line">                    &#123; &quot;from&quot; : 200.0 &#125; &#x2F;&#x2F; price&gt;200的文档归类到一个桶</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &quot;aggregations&quot;: &#123;</span><br><span class="line">        &quot;price_ranges&quot; : &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;buckets&quot;: [ &#x2F;&#x2F; 桶聚合结果</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: &quot;*-100.0&quot;, &#x2F;&#x2F; key可以表达分桶的范围</span><br><span class="line">                    &quot;to&quot;: 100.0, &#x2F;&#x2F; 结束值</span><br><span class="line">                    &quot;doc_count&quot;: 2 &#x2F;&#x2F; 默认按Value Count指标聚合，统计桶内文档总数</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: &quot;100.0-200.0&quot;,</span><br><span class="line">                    &quot;from&quot;: 100.0, &#x2F;&#x2F; 起始值</span><br><span class="line">                    &quot;to&quot;: 200.0, &#x2F;&#x2F; 结束值</span><br><span class="line">                    &quot;doc_count&quot;: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;key&quot;: &quot;200.0-*&quot;,</span><br><span class="line">                    &quot;from&quot;: 200.0,</span><br><span class="line">                    &quot;doc_count&quot;: 3</span><br><span class="line">                &#125;</span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家仔细观察的话，发现range分桶，默认key的值不太友好，尤其开发的时候，不知道key长什么样子，处理起来比较麻烦，我们可以为每一个分桶指定一个有意义的名字。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;price_ranges&quot; : &#123;</span><br><span class="line">            &quot;range&quot; : &#123;</span><br><span class="line">                &quot;field&quot; : &quot;price&quot;,</span><br><span class="line">                &quot;keyed&quot; : true,</span><br><span class="line">                &quot;ranges&quot; : [</span><br><span class="line">                    &#x2F;&#x2F; 通过key参数，配置每一个分桶的名字</span><br><span class="line">                    &#123; &quot;key&quot; : &quot;cheap&quot;, &quot;to&quot; : 100 &#125;,</span><br><span class="line">                    &#123; &quot;key&quot; : &quot;average&quot;, &quot;from&quot; : 100, &quot;to&quot; : 200 &#125;,</span><br><span class="line">                    &#123; &quot;key&quot; : &quot;expensive&quot;, &quot;from&quot; : 200 &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-16-5-综合例子"><a href="#2-16-5-综合例子" class="headerlink" title="2.16.5 综合例子"></a>2.16.5 综合例子</h3><p>前面的例子，都是单独使用aggs聚合语句，代表直接统计所有的文档，实际应用中，经常需要配合query语句，先搜索目标文档，然后使用aggs聚合语句对搜索结果进行统计分析。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cars&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot;: 0, &#x2F;&#x2F; size&#x3D;0代表不需要返回query查询结果，仅仅返回aggs统计结果</span><br><span class="line">    &quot;query&quot; : &#123; &#x2F;&#x2F; 设置查询语句，先赛选文档</span><br><span class="line">        &quot;match&quot; : &#123;</span><br><span class="line">            &quot;make&quot; : &quot;ford&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;aggs&quot; : &#123; &#x2F;&#x2F; 然后对query搜索的结果，进行统计</span><br><span class="line">        &quot;colors&quot; : &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;terms&quot; : &#123; &#x2F;&#x2F; 聚合类型为：terms 先分桶</span><br><span class="line">              &quot;field&quot; : &quot;color&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123; &#x2F;&#x2F; 通过嵌套聚合查询，设置桶内指标聚合条件</span><br><span class="line">              &quot;avg_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">                &quot;avg&quot;: &#123; &#x2F;&#x2F; 聚合类型为: avg指标聚合</span><br><span class="line">                  &quot;field&quot;: &quot;price&quot; &#x2F;&#x2F; 根据price字段计算平均值</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              &quot;sum_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">                &quot;sum&quot;: &#123; &#x2F;&#x2F; 聚合类型为: sum指标聚合</span><br><span class="line">                  &quot;field&quot;: &quot;price&quot; &#x2F;&#x2F; 根据price字段求和</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚合查询支持多层嵌套。</p>
<h2 id="2-17-聚合后排序"><a href="#2-17-聚合后排序" class="headerlink" title="2.17 聚合后排序"></a>2.17 聚合后排序</h2><p>类似terms、histogram、date_histogram这类桶聚合都会动态生成多个桶，如果生成的桶特别多，我们如何确定这些桶的排序顺序，如何限制返回桶的数量。</p>
<h3 id="2-17-1-多桶排序"><a href="#2-17-1-多桶排序" class="headerlink" title="2.17.1 多桶排序"></a>2.17.1 多桶排序</h3><p>默认情况，ES会根据doc_count文档总数，降序排序。</p>
<p>ES桶聚合支持两种方式排序：</p>
<ul>
<li>内置排序</li>
<li>按度量指标排序</li>
</ul>
<p>（1）内置排序</p>
<p>内置排序参数：</p>
<ul>
<li><strong>_count</strong> - 按文档数排序。对 terms 、 histogram 、 date_histogram 有效</li>
<li><strong>_term</strong> - 按词项的字符串值的字母顺序排序。只在 terms 内使用</li>
<li><strong>_key</strong> - 按每个桶的键值数值排序, 仅对 histogram 和 date_histogram 有效</li>
</ul>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cars&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;colors&quot; : &#123; &#x2F;&#x2F; 聚合查询名字，随便取一个</span><br><span class="line">            &quot;terms&quot; : &#123; &#x2F;&#x2F; 聚合类型为: terms</span><br><span class="line">              &quot;field&quot; : &quot;color&quot;, </span><br><span class="line">              &quot;order&quot;: &#123; &#x2F;&#x2F; 设置排序参数</span><br><span class="line">                &quot;_count&quot; : &quot;asc&quot;  &#x2F;&#x2F; 根据_count排序，asc升序，desc降序</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）按度量排序</p>
<p>通常情况下，我们根据桶聚合分桶后，都会对桶内进行多个维度的指标聚合，所以我们也可以根据桶内指标聚合的结果进行排序。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cars&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;size&quot; : 0,</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;colors&quot; : &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;terms&quot; : &#123; &#x2F;&#x2F; 聚合类型: terms，先分桶</span><br><span class="line">              &quot;field&quot; : &quot;color&quot;, &#x2F;&#x2F; 分桶字段为color</span><br><span class="line">              &quot;order&quot;: &#123; &#x2F;&#x2F; 设置排序参数</span><br><span class="line">                &quot;avg_price&quot; : &quot;asc&quot;  &#x2F;&#x2F; 根据avg_price指标聚合结果，升序排序。</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;aggs&quot;: &#123; &#x2F;&#x2F; 嵌套聚合查询，设置桶内聚合指标</span><br><span class="line">                &quot;avg_price&quot;: &#123; &#x2F;&#x2F; 聚合查询名字，前面排序引用的就是这个名字</span><br><span class="line">                    &quot;avg&quot;: &#123;&quot;field&quot;: &quot;price&quot;&#125; &#x2F;&#x2F; 计算price字段平均值</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-17-2-限制返回桶的数量"><a href="#2-17-2-限制返回桶的数量" class="headerlink" title="2.17.2 限制返回桶的数量"></a>2.17.2 限制返回桶的数量</h3><p>如果分桶的数量太多，可以通过给桶聚合增加一个size参数限制返回桶的数量。</p>
<p>例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">    &quot;aggs&quot; : &#123;</span><br><span class="line">        &quot;products&quot; : &#123; &#x2F;&#x2F; 聚合查询名字</span><br><span class="line">            &quot;terms&quot; : &#123; &#x2F;&#x2F; 聚合类型为: terms</span><br><span class="line">                &quot;field&quot; : &quot;product&quot;, &#x2F;&#x2F; 根据product字段分桶</span><br><span class="line">                &quot;size&quot; : 5 &#x2F;&#x2F; 限制最多返回5个桶</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、Kibana-（🌟）"><a href="#三、Kibana-（🌟）" class="headerlink" title="三、Kibana （🌟）"></a>三、Kibana （🌟）</h2><h2 id="3-1-Install"><a href="#3-1-Install" class="headerlink" title="3.1 Install"></a>3.1 Install</h2><p>使用Kibana工具操作ES，Kibana以Web后台的形式提供了一个可视化操作ES的系统，支持根据ES数据绘制图表，支持ES查询<strong>语法自动补全</strong>等高级特性。</p>
<p>Kibana download</p>
<ul>
<li>Windows <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/kibana/kibana-7.5.1-windows-x86_64.zip">kibana-7.5.1-windows-x86_64.zip</a></li>
<li>Linux <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/kibana/kibana-7.5.1-linux-x86_64.tar.gz">kibana-7.5.1-linux-x86_64.tar.gz</a></li>
<li>macOS <a target="_blank" rel="noopener" href="https://artifacts.elastic.co/downloads/kibana/kibana-7.5.1-darwin-x86_64.tar.gz">kibana-7.5.1-darwin-x86_64.tar.gz</a></li>
</ul>
<p>解压缩 &amp; 启动（macOS）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 解压</span><br><span class="line">tar -zxvf kibana-7.5.1-darwin-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line"># 切换到安装目录</span><br><span class="line">cd kibana-7.5.1-darwin-x86_64</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">.&#x2F;bin&#x2F;kibana</span><br></pre></td></tr></table></figure>

<p>访问</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:5601&#x2F;</span><br></pre></td></tr></table></figure>

<p>点击<code>Explore on my own</code>进入后台</p>
<h2 id="3-2-debug-ES-by-Kibana’console"><a href="#3-2-debug-ES-by-Kibana’console" class="headerlink" title="3.2 debug ES by Kibana’console"></a>3.2 debug ES by Kibana’console</h2><p>点击左侧 <code>Dev Tools</code> 进入 <code>Cosole</code> 后台</p>
<h2 id="3-3-新增记录"><a href="#3-3-新增记录" class="headerlink" title="3.3 新增记录"></a>3.3 新增记录</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">method:POST</span><br><span class="line">url:localhost:9200&#x2F;school&#x2F;student&#x2F;1</span><br><span class="line">data:&#123;&quot;name&quot;: &quot;张三&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>![image-20210407195037328](/Users/junmingguo/Library/Application Support/typora-user-images/image-20210407195037328.png)</p>
<h2 id="3-4-导入样例数据"><a href="#3-4-导入样例数据" class="headerlink" title="3.4 导入样例数据"></a>3.4 导入样例数据</h2><p>kibana首页的<code>Add sample data</code>，以航班数据为例，介绍航班数据字段：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;:</span> <span class="string">&quot;kibana_sample_data_flights&quot;</span>, <span class="string">//</span> <span class="string">航班索引名称</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;:</span> <span class="string">&quot;_doc&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;:</span> <span class="string">&quot;MEkjEHMBJlts2AvaxCbj&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_version&quot;:</span> <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;_score&quot;:</span> <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;_source&quot;:</span> &#123;</span><br><span class="line">    <span class="attr">&quot;FlightNum&quot;:</span> <span class="string">&quot;SQIY3O9&quot;</span>, <span class="string">//</span> <span class="string">航班编号</span></span><br><span class="line">    <span class="attr">&quot;DestCountry&quot;:</span> <span class="string">&quot;GB&quot;</span>, <span class="string">//</span> <span class="string">目标国家简称</span></span><br><span class="line">    <span class="attr">&quot;OriginWeather&quot;:</span> <span class="string">&quot;Clear&quot;</span>, <span class="string">//</span> <span class="string">出发天气</span></span><br><span class="line">    <span class="attr">&quot;OriginCityName&quot;:</span> <span class="string">&quot;Osaka&quot;</span>, <span class="string">//</span> <span class="string">出发城市</span></span><br><span class="line">    <span class="attr">&quot;AvgTicketPrice&quot;:</span> <span class="number">644.8724392684487</span>, <span class="string">//</span> <span class="string">平均价格</span></span><br><span class="line">    <span class="attr">&quot;DistanceMiles&quot;:</span> <span class="number">5948.821557153384</span>, <span class="string">//</span> <span class="string">距离，英里</span></span><br><span class="line">    <span class="attr">&quot;FlightDelay&quot;:</span> <span class="literal">true</span>, <span class="string">//</span> <span class="string">航班是否延误</span></span><br><span class="line">    <span class="attr">&quot;DestWeather&quot;:</span> <span class="string">&quot;Clear&quot;</span>, <span class="string">//</span> <span class="string">目的地天气</span></span><br><span class="line">    <span class="attr">&quot;Dest&quot;:</span> <span class="string">&quot;London Gatwick Airport&quot;</span>, <span class="string">//</span> <span class="string">目的地</span></span><br><span class="line">    <span class="attr">&quot;FlightDelayType&quot;:</span> <span class="string">&quot;Carrier Delay&quot;</span>, <span class="string">//</span> <span class="string">航班延误原因</span></span><br><span class="line">    <span class="attr">&quot;OriginCountry&quot;:</span> <span class="string">&quot;JP&quot;</span>, <span class="string">//</span> <span class="string">出发国家</span></span><br><span class="line">    <span class="attr">&quot;timestamp&quot;:</span> <span class="string">&quot;2020-07-02T15:28:44&quot;</span>, <span class="string">//</span> <span class="string">时间</span></span><br><span class="line">    <span class="attr">&quot;DestLocation&quot;:</span> &#123; <span class="string">//</span> <span class="string">目的地经纬度</span></span><br><span class="line">      <span class="attr">&quot;lat&quot;:</span> <span class="string">&quot;51.14810181&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;lon&quot;:</span> <span class="string">&quot;-0.190277994&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;OriginLocation&quot;:</span> &#123; <span class="string">//</span> <span class="string">出发地经纬度</span></span><br><span class="line">      <span class="attr">&quot;lat&quot;:</span> <span class="string">&quot;34.4272995&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;lon&quot;:</span> <span class="string">&quot;135.2440033&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;DestCityName&quot;:</span> <span class="string">&quot;London&quot;</span>, <span class="string">//</span> <span class="string">目的地城市</span></span><br><span class="line">    <span class="string">...忽略....</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查询数据：通过左侧栏的Discover检索数据，需要创建一个索引模式（index pattern），索引模式是支持通配符的索引名表达式，切换索引模式，可以添加多个Sample data，多自动创建多个索引模式</p>
<p>位置：Discover&gt;kibana_sample_data_flights [change]</p>
<p>kibana的discover支持Kibana Query Language (KQL)语法，就是一套简单的查询语法，通过KQL可以编写查询条件查询数据。提示：Kibana Query Language (KQL)语法不等同于Elasticsearch的查询语法。</p>
<h2 id="3-5-KQL语法小结"><a href="#3-5-KQL语法小结" class="headerlink" title="3.5 KQL语法小结"></a>3.5 KQL语法小结</h2><p>Kibana Query Language （KQL）查询语法是Kibana为了简化ES查询设计的一套简单查询语法，Kibana支持索引字段和语法补全，可以非常方便的查询数据。</p>
<h3 id="3-5-1-等值匹配-equals"><a href="#3-5-1-等值匹配-equals" class="headerlink" title="3.5.1 等值匹配(equals)"></a>3.5.1 等值匹配(equals)</h3><p>用于查询字段值，语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字段名: 匹配值</span><br><span class="line">eg. FlightNum: 4H2KUBH</span><br></pre></td></tr></table></figure>

<p>查询FlightNum字段匹配”4H2KUBH”字符串的文档。</p>
<p>等值匹配也支持通配符（*），通过通配符实现模糊搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. FlightNum: 4H*BH</span><br></pre></td></tr></table></figure>

<h3 id="3-5-2-存在检测-exists"><a href="#3-5-2-存在检测-exists" class="headerlink" title="3.5.2 存在检测(exists)"></a>3.5.2 存在检测(exists)</h3><p>匹配包含指定字段的文档，语法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字段名:*</span><br><span class="line">eg. FlightNum:* </span><br></pre></td></tr></table></figure>

<p>匹配包含FlightNum字段的文档。</p>
<h3 id="3-5-3-关系运算符"><a href="#3-5-3-关系运算符" class="headerlink" title="3.5.3 关系运算符"></a>3.5.3 关系运算符</h3><p>关系运算符只能用在数值和时间类型的字段</p>
<p>支持关系运算符如下：</p>
<ul>
<li>&lt;= 小于等于</li>
<li>&gt;= 大于等于</li>
<li>&lt; 小于</li>
<li>&gt; 大于</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. AvgTicketPrice &gt;&#x3D; 300</span><br></pre></td></tr></table></figure>

<h3 id="3-5-4-逻辑运算符"><a href="#3-5-4-逻辑运算符" class="headerlink" title="3.5.4 逻辑运算符"></a>3.5.4 逻辑运算符</h3><p>支持逻辑运算符如下:</p>
<ul>
<li>and</li>
<li>or</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eg. AvgTicketPrice &gt; 300 and AvgTicketPrice &lt; 600 </span><br></pre></td></tr></table></figure>

<p>AvgTicketPrice大于300且AvgTicketPrice小于600</p>
<h2 id="3-6-查询航班样例数据"><a href="#3-6-查询航班样例数据" class="headerlink" title="3.6 查询航班样例数据"></a>3.6 查询航班样例数据</h2><ul>
<li>查询航班编号等于LVOO2CA的航班信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlightNum: LVOO2CA</span><br></pre></td></tr></table></figure>

<ul>
<li>同时查询下面索引的数据<ul>
<li>tizi365_log_202005</li>
<li>tizi365_log_202006</li>
<li>tizi365_log_202007</li>
</ul>
</li>
</ul>
<p>可以使用<code>tizi365_log_*</code>作为索引模式，可以匹配以tizi365_log_为前缀的所有索引名</p>
<ul>
<li>查询航班机票平均价格大于300且小于600的航班信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AvgTicketPrice &gt; 300 and AvgTicketPrice &lt; 600 </span><br></pre></td></tr></table></figure>

<ul>
<li>查询航班编号等于 1MAEYXT 的航班信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlightNum : 1MAEYXT</span><br></pre></td></tr></table></figure>

<h2 id="3-7-Discover-菜单栏"><a href="#3-7-Discover-菜单栏" class="headerlink" title="3.7 Discover 菜单栏"></a>3.7 Discover 菜单栏</h2><p>Discover &gt; Selected fields （显示当前选择的字段）</p>
<p>​                &gt; Available fields （可选择的字段）</p>
<h2 id="3-8-图表可视化"><a href="#3-8-图表可视化" class="headerlink" title="3.8 图表可视化"></a>3.8 图表可视化</h2><p>结合ES聚合查询语句生成图表，Visualize可查看已创建的图表</p>
<h2 id="3-9-debug-ES-查询语句"><a href="#3-9-debug-ES-查询语句" class="headerlink" title="3.9 debug ES 查询语句"></a>3.9 debug ES 查询语句</h2><p>Dev tools中查询数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;kibana_sample_data_flights&#x2F;_search</span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;match&quot;: &#123;</span><br><span class="line">			&quot;FlightNum&quot;: &quot;SQIY309&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-10-配置"><a href="#3-10-配置" class="headerlink" title="3.10 配置"></a>3.10 配置</h2><p>默认安装，Kibana会自动连接本地安装的Elasticsearch，本节详细介绍Kibana的配置项。</p>
<p>配置文件路径：${kibana安装目录}/config/kibana.yml</p>
<p>Kibana使用Yaml格式描述配置项。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 端口号</span></span><br><span class="line"><span class="attr">server.port:</span> <span class="number">5601</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line"><span class="attr">server.host:</span> <span class="string">&quot;localhost&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ES服务地址</span></span><br><span class="line"><span class="attr">elasticsearch.hosts:</span> [<span class="string">&quot;http://localhost:9200&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># ES账号 ES没有设置账号密码可以不配置。</span></span><br><span class="line"><span class="comment">#elasticsearch.username: &quot;kibana&quot;</span></span><br><span class="line"><span class="comment"># ES密码</span></span><br><span class="line"><span class="comment">#elasticsearch.password: &quot;pass&quot;</span></span><br></pre></td></tr></table></figure>

<p>参数配置说明</p>
<ul>
<li>server.port:<br>默认值: 5601 Kibana 由后端服务器提供服务，该配置指定使用的端口号。</li>
<li>server.host:<br>默认值: “localhost” 指定后端服务器的主机地址。</li>
<li>server.basePath:<br>如果启用了代理，指定 Kibana 的路径，该配置项只影响 Kibana 生成的 URLs，转发请求到 Kibana 时代理会移除基础路径值，该配置项不能以斜杠 (/)结尾。</li>
<li>server.maxPayloadBytes:<br>默认值: 1048576 服务器请求的最大负载，单位字节。</li>
<li>server.name:<br>默认值: “您的主机名” Kibana 实例对外展示的名称。</li>
<li>server.defaultRoute:<br>默认值: “/app/kibana” Kibana 的默认路径，该配置项可改变 Kibana 的登录页面。</li>
<li>elasticsearch.url:<br>默认值: “<a href="http://localhost:9200&quot;">http://localhost:9200&quot;</a> 用来处理所有查询的 Elasticsearch 实例的 URL 。</li>
<li>elasticsearch.preserveHost:<br>默认值: true 该设置项的值为 true 时，Kibana 使用 server.host 设定的主机名，该设置项的值为 false 时，Kibana 使用主机的主机名来连接 Kibana 实例。</li>
<li>kibana.index:<br>默认值: “.kibana” Kibana 使用 Elasticsearch 中的索引来存储保存的检索，可视化控件以及仪表板。如果没有索引，Kibana 会创建一个新的索引。</li>
<li>kibana.defaultAppId:<br>默认值: “discover” 默认加载的应用。</li>
<li>tilemap.url:<br>Kibana 用来在 tile 地图可视化组件中展示地图服务的 URL。默认时，Kibana 从外部的元数据服务读取 url，用户也可以覆盖该参数，使用自己的 tile 地图服务。例如：”<a target="_blank" rel="noopener" href="https://tiles.elastic.co/v2/default/%7Bz%7D/%7Bx%7D/%7By%7D.png?elastic_tile_service_tos=agree&amp;my_app_name=kibana&quot;">https://tiles.elastic.co/v2/default/{z}/{x}/{y}.png?elastic_tile_service_tos=agree&amp;my_app_name=kibana&quot;</a></li>
<li>tilemap.options.minZoom:<br>默认值: 1 最小缩放级别。</li>
<li>tilemap.options.maxZoom:<br>默认值: 10 最大缩放级别。</li>
<li>tilemap.options.attribution:<br>默认值: “© <a target="_blank" rel="noopener" href="https://www.elastic.co/elastic-tile-service">Elastic Tile Service</a>“ 地图属性字符串。</li>
<li>tilemap.options.subdomains:<br>服务使用的二级域名列表，用 {s} 指定二级域名的 URL 地址。</li>
<li>elasticsearch.username: 和 elasticsearch.password:<br>Elasticsearch 设置了基本的权限认证，该配置项提供了用户名和密码，用于 Kibana 启动时维护索引。Kibana 用户仍需要 Elasticsearch 由 Kibana 服务端代理的认证。</li>
<li>server.ssl.enabled<br>默认值: “false” 对到浏览器端的请求启用 SSL，设为 true 时， server.ssl.certificate 和 server.ssl.key 也要设置。</li>
<li>server.ssl.certificate: 和 server.ssl.key:<br>PEM 格式 SSL 证书和 SSL 密钥文件的路径。</li>
<li>server.ssl.keyPassphrase<br>解密私钥的口令，该设置项可选，因为密钥可能没有加密。</li>
<li>server.ssl.certificateAuthorities<br>可信任 PEM 编码的证书文件路径列表。</li>
<li>server.ssl.supportedProtocols<br>默认值: TLSv1、TLSv1.1、TLSv1.2 版本支持的协议，有效的协议类型: TLSv1 、 TLSv1.1 、 TLSv1.2 。</li>
<li>server.ssl.cipherSuites<br>默认值: ECDHE-RSA-AES128-GCM-SHA256, ECDHE-ECDSA-AES128-GCM-SHA256, ECDHE-RSA-AES256-GCM-SHA384, ECDHE-ECDSA-AES256-GCM-SHA384, DHE-RSA-AES128-GCM-SHA256, ECDHE-RSA-AES128-SHA256, DHE-RSA-AES128-SHA256, ECDHE-RSA-AES256-SHA384, DHE-RSA-AES256-SHA384, ECDHE-RSA-AES256-SHA256, DHE-RSA-AES256-SHA256, HIGH,!aNULL, !eNULL, !EXPORT, !DES, !RC4, !MD5, !PSK, !SRP, !CAMELLIA. 具体格式和有效参数可通过<a target="_blank" rel="noopener" href="https://www.openssl.org/docs/man1.0.2/apps/ciphers.html#CIPHER-LIST-FORMAT">OpenSSL cipher list format documentation</a> 获得。</li>
<li>elasticsearch.ssl.certificate: 和 elasticsearch.ssl.key:<br>可选配置项，提供 PEM格式 SSL 证书和密钥文件的路径。这些文件确保 Elasticsearch 后端使用同样的密钥文件。</li>
<li>elasticsearch.ssl.keyPassphrase<br>解密私钥的口令，该设置项可选，因为密钥可能没有加密。</li>
<li>elasticsearch.ssl.certificateAuthorities:<br>指定用于 Elasticsearch 实例的 PEM 证书文件路径。</li>
<li>elasticsearch.ssl.verificationMode:<br>默认值: full 控制证书的认证，可用的值有 none 、 certificate 、 full 。 full 执行主机名验证，certificate 不执行主机名验证。</li>
<li>elasticsearch.pingTimeout:<br>默认值: elasticsearch.requestTimeout setting 的值，等待 Elasticsearch 的响应时间。</li>
<li>elasticsearch.requestTimeout:<br>默认值: 30000 等待后端或 Elasticsearch 的响应时间，单位微秒，该值必须为正整数。</li>
<li>elasticsearch.requestHeadersWhitelist:<br>默认值: [ ‘authorization’ ] Kibana 客户端发送到 Elasticsearch 头体，发送 no 头体，设置该值为[]。</li>
<li>elasticsearch.customHeaders:<br>默认值: {} 发往 Elasticsearch的头体和值， 不管 elasticsearch.requestHeadersWhitelist 如何配置，任何自定义的头体不会被客户端头体覆盖。</li>
<li>elasticsearch.shardTimeout:<br>默认值: 0 Elasticsearch 等待分片响应时间，单位微秒，0即禁用。</li>
<li>elasticsearch.startupTimeout:<br>默认值: 5000 Kibana 启动时等待 Elasticsearch 的时间，单位微秒。</li>
<li>pid.file:<br>指定 Kibana 的进程 ID 文件的路径。</li>
<li>logging.dest:<br>默认值: stdout 指定 Kibana 日志输出的文件。</li>
<li>logging.silent:<br>默认值: false 该值设为 true 时，禁止所有日志输出。</li>
<li>logging.quiet:<br>默认值: false 该值设为 true 时，禁止除错误信息除外的所有日志输出。</li>
<li>logging.verbose<br>默认值: false 该值设为 true 时，记下所有事件包括系统使用信息和所有请求的日志。</li>
<li>ops.interval<br>默认值: 5000 设置系统和进程取样间隔，单位微妙，最小值100。</li>
<li>status.allowAnonymous<br>默认值: false 如果启用了权限，该项设置为 true 即允许所有非授权用户访问 Kibana 服务端 API 和状态页面。</li>
<li>cpu.cgroup.path.override<br>如果挂载点跟 /proc/self/cgroup 不一致，覆盖 cgroup cpu 路径。</li>
<li>cpuacct.cgroup.path.override<br>如果挂载点跟 /proc/self/cgroup 不一致，覆盖 cgroup cpuacct 路径。</li>
<li>console.enabled<br>默认值: true 设为 false 来禁用控制台，切换该值后服务端下次启动时会重新生成资源文件，因此会导致页面服务有点延迟。</li>
<li>elasticsearch.tribe.url:<br>Elasticsearch tribe 实例的 URL，用于所有查询。</li>
<li>elasticsearch.tribe.username: 和 elasticsearch.tribe.password:<br>Elasticsearch 设置了基本的权限认证，该配置项提供了用户名和密码，用于 Kibana 启动时维护索引。Kibana 用户仍需要 Elasticsearch 由 Kibana 服务端代理的认证。</li>
<li>elasticsearch.tribe.ssl.certificate: 和 elasticsearch.tribe.ssl.key:<br>可选配置项，提供 PEM 格式 SSL 证书和密钥文件的路径。这些文件确保 Elasticsearch 后端使用同样的密钥文件。</li>
<li>elasticsearch.tribe.ssl.keyPassphrase<br>解密私钥的口令，该设置项可选，因为密钥可能没有加密。</li>
<li>elasticsearch.tribe.ssl.certificateAuthorities:<br>指定用于 Elasticsearch tribe 实例的 PEM 证书文件路径。</li>
<li>elasticsearch.tribe.ssl.verificationMode:<br>默认值: full 控制证书的认证，可用的值有 none 、 certificate 、 full 。 full 执行主机名验证， certificate 不执行主机名验证。</li>
<li>elasticsearch.tribe.pingTimeout:<br>默认值: elasticsearch.tribe.requestTimeout setting 的值，等待 Elasticsearch 的响应时间。</li>
<li>elasticsearch.tribe.requestTimeout:<br>Default: 30000 等待后端或 Elasticsearch 的响应时间，单位微秒，该值必须为正整数。</li>
<li>elasticsearch.tribe.requestHeadersWhitelist:<br>默认值: [ ‘authorization’ ] Kibana 发往 Elasticsearch 的客户端头体，发送 no 头体，设置该值为[]。</li>
<li>elasticsearch.tribe.customHeaders:<br>默认值: {} 发往 Elasticsearch的头体和值，不管 elasticsearch.tribe.requestHeadersWhitelist 如何配置，任何自定义的头体不会被客户端头体覆盖</li>
</ul>
<h2 id="3-11-Dev-Tools"><a href="#3-11-Dev-Tools" class="headerlink" title="3.11 Dev Tools"></a>3.11 Dev Tools</h2><p>Kibana开发工具（Dev Tools）主要提供了下面三种功能</p>
<ul>
<li>调试Elasticsearch查询表达式</li>
<li>分析Elasticsearch查询表达式性能</li>
<li>调试grok</li>
</ul>
<h3 id="3-11-1-Console"><a href="#3-11-1-Console" class="headerlink" title="3.11.1 Console"></a>3.11.1 Console</h3><p>通过Console（控制台）调试Elasticsearch查询表达式</p>
<h3 id="3-11-2-Search-Profiler-搜索性能分析"><a href="#3-11-2-Search-Profiler-搜索性能分析" class="headerlink" title="3.11.2 Search Profiler 搜索性能分析"></a>3.11.2 Search Profiler 搜索性能分析</h3><p>分析Elasticsearch查询表达式性能</p>
<ol>
<li>输入需要分析的索引模式</li>
<li>输入需要分析的ES表达式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eg. </span><br><span class="line">&#123;</span><br><span class="line">	&quot;query&quot;: &#123;</span><br><span class="line">		&quot;match&quot;: &#123;</span><br><span class="line">			&quot;FlightNum&quot;: &quot;SQIY309&quot;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Click Profile 开始分析</li>
</ol>
<h3 id="3-11-3-Grok-Debugger"><a href="#3-11-3-Grok-Debugger" class="headerlink" title="3.11.3 Grok Debugger"></a>3.11.3 Grok Debugger</h3><p>主要用于支持在线调试Logstash grok表达式</p>
<h2 id="四、Logstash-（🌟）"><a href="#四、Logstash-（🌟）" class="headerlink" title="四、Logstash （🌟）"></a>四、Logstash （🌟）</h2><p>Logstash是一个数据同步工具，在ELK（Elasticsearch + Logstash + Kibana）技术栈中解决数据同步问题。日常项目中数据主要存储在MYSQL、日志文件中，通过Logstash可以将MYSQL、日志文件、redis等多种数据源的数据同步到ES，这样就可以通过ES搜索数据。</p>
<p>MYSQL同步数据到Elasticsearch，主要有下面几种策略：</p>
<ul>
<li>双写策略，更新MYSQL数据的同时通过ES API直接写入数据到ES （同步方式）</li>
<li>通过Logstash同步数据到ES （异步方式）</li>
<li>通过订阅MYSQL Binlog，将数据同步到ES （异步方式）</li>
</ul>
<p>这里主要介绍Logstash如何同步数据。</p>
<h2 id="4-1-Install"><a href="#4-1-Install" class="headerlink" title="4.1 Install"></a>4.1 Install</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 下载最新版本的压缩包（linux&#x2F;mac系统下载tar.gz, windows下载zip）</span><br><span class="line">https:&#x2F;&#x2F;www.elastic.co&#x2F;cn&#x2F;downloads&#x2F;logstash</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line">tar -zxvf logstash-7.7.1.tar.gz</span><br><span class="line"></span><br><span class="line"># 切换到安装目录</span><br><span class="line">cd logstash-7.7.1</span><br><span class="line"></span><br><span class="line"># 执行命令</span><br><span class="line">bin&#x2F;logstash -e &#39;input &#123; stdin &#123; &#125; &#125; output &#123; stdout &#123;&#125; &#125;&#39;</span><br></pre></td></tr></table></figure>

<p>logstash启动后在控制台输入<code>abc</code>按回车，可以看到类似下面的输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">abc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;@timestamp&quot; &#x3D;&gt; 2020-06-09T15:45:38.147Z,</span><br><span class="line">       &quot;message&quot; &#x3D;&gt; &quot;abc&quot;,</span><br><span class="line">      &quot;@version&quot; &#x3D;&gt; &quot;1&quot;,</span><br><span class="line">          &quot;host&quot; &#x3D;&gt; &quot;JUNMINGGUO-MB0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加config.reload.automatic命令参数，自动加载配置，不需要重新启动logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash -f tizi.conf --config.reload.automatic</span><br></pre></td></tr></table></figure>

<p>配置文件</p>
<p>可以将Logstash的配置都写入一个配置文件中，下面是配置文件的格式，主要有三部分组成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 输入插件配置, 主要配置需要同步的数据源，例如：MYSQL</span><br><span class="line">input &#123;</span><br><span class="line">&#125;</span><br><span class="line"># 过滤器插件配置， 主要用于对输入的数据进行过滤，格式化操作，filter是可选的。</span><br><span class="line">filter &#123;</span><br><span class="line"> &#125;</span><br><span class="line"># 输出插件配置，主要配置同步数据的目的地，例如同步到ES</span><br><span class="line">output &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提示：logstash的input、filter、output都是由各种插件组成。</p>
<p>例子：创建一个myconf.conf配置文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    stdin &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    stdout &#123; codec &#x3D;&gt; rubydebug &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>这个配置文件的意思是，从控制台标准输入（stdin）接收输入，然后直接将结果在控制台标准输出（stdout）打印出来。</p>
<p>通过配置文件启动logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash -f myconf.conf</span><br></pre></td></tr></table></figure>

<p>同步nginx日志到ES</p>
<p>下面是将Nginx的访问日志同步到ES中的配置</p>
<p>配置文件名：myconf.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">    # 实时监控日志文件的内容，类似tail -f 命令的作用</span><br><span class="line">    file &#123;</span><br><span class="line">        # nginx日志文件路径</span><br><span class="line">        path &#x3D;&gt; [ &quot;&#x2F;data&#x2F;nginx&#x2F;logs&#x2F;nginx_access.log&quot; ]</span><br><span class="line">        start_position &#x3D;&gt; &quot;beginning&quot;</span><br><span class="line">        ignore_older &#x3D;&gt; 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 配置过滤器对日志文件进行格式化</span><br><span class="line">filter &#123;</span><br><span class="line">    # 使用grok插件对日志内容进行格式化，提取日志内容，方便转换成json格式</span><br><span class="line">    # %COMBINEDAPACHELOG 是grok插件内置的apache日志内容处理模板，其实就是一些表达式，用来格式日志文本内容，也可以格式化Nginx日志</span><br><span class="line">    grok &#123;</span><br><span class="line">        match &#x3D;&gt; &#123;</span><br><span class="line">            &quot;message&quot; &#x3D;&gt; &quot;%&#123;COMBINEDAPACHELOG&#125;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 配置输出目的地，这里配置同步到ES中</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">        # es服务器地址</span><br><span class="line">        hosts &#x3D;&gt; [&quot;127.0.0.1:9200&quot;]</span><br><span class="line">        # 目标索引</span><br><span class="line">        index &#x3D;&gt; &quot;nginx-access&quot;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动logstash</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin&#x2F;logstash -f myconf.conf</span><br></pre></td></tr></table></figure>

<h2 id="4-2-工作原理"><a href="#4-2-工作原理" class="headerlink" title="4.2 工作原理"></a>4.2 工作原理</h2><p>Logstash同步数据，主要有三个核心环节：inputs → filters → outputs，流程如下图。</p>
<p><img src="https://www.tizi365.com/wp-content/uploads/2020/06/basic_logstash_pipeline-1024x228.png" alt="img"></p>
<p>inputs模块负责收集数据，filters模块可以对收集到的数据进行格式化、过滤、简单的数据处理，outputs模块负责将数据同步到目的地，Logstash的处理流程，就像管道一样，数据从管道的一端，流向另外一端。</p>
<p>提示：inputs/filters/outputs是通过插件机制扩展各种能力。</p>
<h3 id="4-2-1-inputs"><a href="#4-2-1-inputs" class="headerlink" title="4.2.1 inputs"></a>4.2.1 inputs</h3><p>inputs可以收集多种数据源的数据，下面是常见的数据源：</p>
<ul>
<li>file - 扫描磁盘中的文件数据，例如： 扫描日志文件。</li>
<li>mysql - 扫描Mysql的表数据</li>
<li>redis</li>
<li>Filebeat - 轻量级的文件数据采集器，可以取代file的能力。</li>
<li>消息队列kafka、rabbitmq等 - 支持从各种消息队列读取数据。</li>
</ul>
<h3 id="4-2-2-filters"><a href="#4-2-2-filters" class="headerlink" title="4.2.2 filters"></a>4.2.2 filters</h3><p>filters是一个可选模块，可以在数据同步到目的地之前，对数据进行一些格式化、过滤、简单的数据处理操作。</p>
<p>常用的filters功能：</p>
<ul>
<li>grok - 功能强大文本处理插件，主要用于格式化文本内容。</li>
<li>drop - 丢弃一些数据</li>
</ul>
<h3 id="4-2-3-outputs"><a href="#4-2-3-outputs" class="headerlink" title="4.2.3 outputs"></a>4.2.3 outputs</h3><p>Logstatsh的最后一个处理节点，outputs负责将数据同步到目的地。</p>
<p>下面是常见的目的地：</p>
<ul>
<li>elasticsearch</li>
<li>file - 也可以将数据同步到一个文件中</li>
</ul>
<h3 id="4-2-4-Codecs"><a href="#4-2-4-Codecs" class="headerlink" title="4.2.4 Codecs"></a>4.2.4 Codecs</h3><p>codecs就是编码器，负责对数据进行序列号处理，主要就是json和文本两种编码器。</p>
<h2 id="4-3-Filebeat-教程"><a href="#4-3-Filebeat-教程" class="headerlink" title="4.3 Filebeat 教程"></a>4.3 Filebeat 教程</h2><p>logstash虽然也支持从磁盘文件中收集数据，但是logstash自己本身还是比较重，对资源的消耗也比较大，尤其是在容器化环境，每个容器都部署logstash也太浪费资源，因此出现了轻量级的日志文件数据收集方案Filebeat，Filebeat将收集到的文件数据传给Logstatsh处理即可。</p>
<h3 id="4-3-1-Filebeat部署架构"><a href="#4-3-1-Filebeat部署架构" class="headerlink" title="4.3.1 Filebeat部署架构"></a>4.3.1 Filebeat部署架构</h3><p><img src="https://www.tizi365.com/wp-content/uploads/2020/06/filebeat.png" alt="img"></p>
<p>可以在每一台服务器或者每一个容器中安装Filebeat，Filebeat负责收集日志数据，然后将日志数据交给Logstash处理，Logstash在将数据导入ES。</p>
<h3 id="4-3-2-Install"><a href="#4-3-2-Install" class="headerlink" title="4.3.2 Install"></a>4.3.2 Install</h3><p>下载安装包，然后解压即可。</p>
<p>官网下载地址：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;www.elastic.co&#x2F;cn&#x2F;downloads&#x2F;beats&#x2F;filebeat</span><br></pre></td></tr></table></figure>

<p>下面以7.7.1版本为例</p>
<p>mac</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;beats&#x2F;filebeat&#x2F;filebeat-7.7.1-darwin-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzvf filebeat-7.7.1-darwin-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<p>linux</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -L -O https:&#x2F;&#x2F;artifacts.elastic.co&#x2F;downloads&#x2F;beats&#x2F;filebeat&#x2F;filebeat-7.7.1-linux-x86_64.tar.gz</span><br><span class="line"></span><br><span class="line">tar xzvf filebeat-7.7.1-linux-x86_64.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-Filebeat配置"><a href="#4-3-3-Filebeat配置" class="headerlink" title="4.3.3 Filebeat配置"></a>4.3.3 Filebeat配置</h3><p>Filebeat的配置结构类似Logstash，也需要配置input和output，分别配置输入和输出，Filebeat使用yaml格式编写配置文件。</p>
<p>默认配置文件路径：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$&#123;安装目录&#125;&#x2F;filebeat.yml</span><br><span class="line">&#x2F;etc&#x2F;filebeat&#x2F;filebeat.yml</span><br><span class="line">&#x2F;usr&#x2F;share&#x2F;filebeat&#x2F;filebeat.yml</span><br></pre></td></tr></table></figure>

<p>因为我们使用的是tar安装包安装，所以选择${安装目录}/filebeat.yml 路径。</p>
<p>配置例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 配置采集数据源</span><br><span class="line">filebeat.inputs:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">    - &#x2F;var&#x2F;log&#x2F;messages</span><br><span class="line">    - &#x2F;var&#x2F;log&#x2F;*.log</span><br><span class="line"># 配置输出目标，这里将数据投递给logstash</span><br><span class="line">output.logstash:</span><br><span class="line">  # logstash地址</span><br><span class="line">  hosts: [&quot;127.0.0.1:5044&quot;]</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>type为log类型，表示收集日志文件数据，paths是一个文件路径数组，这里扫描/var/log/messages文件和/var/log/目录下所有以log为扩展名的日志文件。</p>
<h3 id="4-3-4-Logstash-beat配置"><a href="#4-3-4-Logstash-beat配置" class="headerlink" title="4.3.4 Logstash beat配置"></a>4.3.4 Logstash beat配置</h3><p>配置Logstash的input,让Logstash可以接收Filebeat投递过来的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  # 配置接收Filebeat数据源，监听端口为5044</span><br><span class="line">  # Filebeat的output.logstash地址保持跟这里一致</span><br><span class="line">  beats &#123;</span><br><span class="line">    port &#x3D;&gt; 5044</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">output &#123;</span><br><span class="line">  # 将数据导入到ES中</span><br><span class="line">  elasticsearch &#123;</span><br><span class="line">    hosts &#x3D;&gt; [&quot;http:&#x2F;&#x2F;localhost:9200&quot;]</span><br><span class="line">    index &#x3D;&gt; &quot;tizi365&quot; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-5-启动Filebeat"><a href="#4-3-5-启动Filebeat" class="headerlink" title="4.3.5 启动Filebeat"></a>4.3.5 启动Filebeat</h3><p>进入filebeat安装目录</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;filebeat -c filebeat.yml</span><br></pre></td></tr></table></figure>

<p>如果配置PATH，直接启动即可。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/07/EKL/" data-id="ckn8tlkac000e2etd1yik2xek" data-title="EKL" class="article-share-link">Teilen</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/04/06/Sentry/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Älter</strong>
      <div class="article-nav-title">Sentry</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Kategorien</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Django/">Django</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Go/">Go</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Notes/">Notes</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python/">Python</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/SQL/">SQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Tools/">Tools</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/idea/">idea</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/nosql/">nosql</a></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/07/EKL/">EKL</a>
          </li>
        
          <li>
            <a href="/2021/04/06/Sentry/">Sentry</a>
          </li>
        
          <li>
            <a href="/2021/04/01/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94k8s/">日常笔记——k8s</a>
          </li>
        
          <li>
            <a href="/2021/04/01/%E6%97%A5%E5%B8%B8%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Python/">日常笔记——Python</a>
          </li>
        
          <li>
            <a href="/2021/03/25/%E6%9C%AC%E5%9C%B0%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E7%BB%9F%E8%AE%A1%E5%B7%A5%E5%85%B7%E2%80%94%E2%80%94Coverage/">本地单元测试统计工具——Coverage</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Jimmy Guo<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>